// generated by txt2c.pl from 
#include <stdlib.h>
#ifdef LDLANG_DE
char *HelpTextDe[] = {
    "",
    "ANWEISUNGS-VERZEICHNIS",
    "======================",
    "",
    "> KONTAKT, SCHLIESSER           XName        RName        YName",
    "                             ----] [----  ----] [----  ----] [----",
    "",
    "Wenn ein ‘unwahres’ Signal diese Anweisung erreicht, so ist das",
    "Ausgangssignal ‘unwahr’. Wenn ein ‘wahres’ Signal diese Anweisung",
    "erreicht, so ist das Ausgangssignal ‘wahr’. Dies nur, falls der",
    "vorliegende Eingangspin, Ausgangspin oder eines Merkers (Hilfsrelais)",
    "‘wahr’ ist, anderenfalls ist es unwahr. Diese Anweisung fragt den Status",
    "(Zustand) eines Eingangspins, Ausgangspins oder Merkers (Hilfsrelais) ab.",
    "",
    "",
    "> KONTAKT, ÖFFNER              XName        RName        YName",
    "                            ----]/[----  ----]/[----  ----]/[----",
    "",
    "Wenn ein ‘unwahres’ Signal diese Anweisung erreicht, so ist das",
    "Ausgangssignal ‘unwahr’. Wenn ein ‘wahres’ Signal diese Anweisung",
    "erreicht, so ist das Ausgangssignal ‘wahr’. Dies nur, falls der",
    "vorliegende Eingangspin, Ausgangspin oder der Merker (= internes",
    "Hilfsrelais) ‘unwahr’ ist, anderenfalls ist es ‘unwahr’. Diese Anweisung",
    "fragt den Status (Zustand) eines Eingangspins, Ausgangspins oder Merkers",
    "(Hilfsrelais) ab. Dies ist das Gegenteil eines Schließers.",
    "",
    "",
    "> SPULE, NORMAL (MERKER,AUSGANG)    RName           YName",
    "                                  ----( )----     ----( )----",
    "",
    "Wenn ein ‘unwahres’ Signal diese Anweisung erreicht, so wird der",
    "vorliegende Merker (Hilfsrelais) oder Ausgangspin nicht angesteuert. Wenn",
    "ein ‘wahres’ Signal diese Anweisung erreicht, so wird der vorliegende",
    "Merker (Hilfsrelais) oder Ausgangspin angesteuert. Es ist nicht sinnvoll",
    "dieser Spule eine Eingangsvariable zuzuweisen. Diese Anweisung muss",
    "ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> SPULE, NEGIERT (MERKER,AUSGANG)   RName          YName",
    "                                  ----(/)----   ----(/)----",
    "",
    "Wenn ein ‘wahres’ Signal diese Anweisung erreicht, so wird der vorliegende",
    "Merker (Hilfsrelais)oder Ausgangspin nicht angesteuert. Wenn ein",
    "‘unwahres’ Signal diese Anweisung erreicht, so wird der vorliegende Merker",
    "(Hilfsrelais) oder Ausgangspin angesteuert. Es ist nicht sinnvoll dieser",
    "Spule eine Eingangsvariable zuzuweisen. Dies ist das Gegenteil einer",
    "normalen Spule. Diese Anweisung muss im Netzwerk ganz rechts stehen.",
    "",
    "",
    "> SPULE, SETZEN      RName           YName",
    "                  ----(S)----     ----(S)----",
    "",
    "Wenn ein ‘wahres’ Signal diese Anweisung erreicht, so wird der vorliegende",
    "Merker (Hilfsrelais)oder Ausgangspin auf ‘wahr’ gesetzt. Anderenfalls",
    "bleibt der Status (Zustand) des Merkers (Hilfsrelais) oder Ausgangspins",
    "unverändert.  Diese Anweisung kann nur den Status (Zustand) einer Spule",
    "von ‘unwahr’ nach ‘wahr’ verändern, insofern wird diese üblicherweise in",
    "einer Kombination mit einer Rücksetz-Anweisung für eine Spule verwendet.",
    "Diese Anweisung muss ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> SPULE, RÜCKSETZEN    RName           YName",
    "                    ----(R)----     ----(R)----",
    "",
    "Wenn ein ‘wahres’ Signal diese Anweisung erreicht, so wird der vorliegende",
    "Merker (Hilfsrelais) oder Ausgangspin rückgesetzt. Anderenfalls bleibt der",
    "Status (Zustand) des Merkers (Hilfsrelais) oder Ausgangspins unverändert.",
    "Diese Anweisung kann nur den Status (Zustand) einer Spule von ‘wahr’ nach",
    "‘unwahr’ verändern, insofern wird diese üblicherweise in einer Kombination",
    "mit einer Setz-Anweisung für eine Spule verwendet. Diese Anweisung muss",
    "ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> ANZUGSVERZÖGERUNG         Tdon",
    "                      -[TON 1.000 s]-",
    "",
    "Wenn ein Signal diese Anweisung erreicht, welches seinen Status",
    "(Zustand) von ‘unwahr’ nach ‘wahr’ ändert, so bleibt das Ausgangssignal",
    "für 1,000 s ‘unwahr’, dann wird es ‘wahr’. Wenn ein Signal diese",
    "Anweisung erreicht, welches seinen Status (Zustand) von ‘wahr’ nach",
    "‘unwahr’ ändert, so wird das Ausgangssignal sofort ‘unwahr’. Der Timer",
    "wird jedes Mal rückgesetzt (bzw. auf Null gesetzt), wenn der Eingang",
    "‘unwahr’ wird. Der Eingang muss für 1000 aufeinanderfolgende Millisekunden",
    "‘wahr’ bleiben, bevor auch der Ausgang ‘wahr’ wird. Die Verzögerung",
    "ist konfigurierbar.",
    "",
    "Die ‘TName’ Variable zählt, in der Einheit der jeweiligen Zykluszeit,",
    "von Null ab hoch. Der Ausgang der TON-Anweisung wird wahr, wenn die",
    "Zählervariable größer oder gleich der vorliegenden Verzögerung ist.",
    "Es möglich die Zählervariable an einer anderen Stelle im Programm zu",
    "bearbeiten, zum Beispiel mit einer TRANSFER-Anweisung (MOV).",
    "",
    "",
    "> ABFALLVERZÖGERUNG         Tdoff",
    "                      -[TOF 1.000 s]-",
    "",
    "Wenn ein  Signal diese Anweisung erreicht, welches seinen Status",
    "(Zustand) von ‘wahr’ nach ‘unwahr’ ändert, so bleibt das Ausgangssignal",
    "für 1,000 s ‘wahr’, dann wird es ‘unwahr’. Wenn ein Signal diese",
    "Anweisung erreicht, welches seinen Status (Zustand) von ‘unwahr’ nach",
    "‘wahr’ ändert, so wird das Ausgangssignal sofort ‘wahr’. Der Timer wird",
    "jedes Mal rückgesetzt (bzw. auf Null gesetzt), wenn der Eingang ‘unwahr’",
    "wird. Der Eingang muss für 1000 aufeinanderfolgende Millisekunden ‘unwahr’",
    "bleiben, bevor auch der Ausgang ‘unwahr’ wird. Die Verzögerung ist",
    "konfigurierbar.",
    "",
    "Die ‘TName’ Variable zählt, in der Einheit der jeweiligen Zykluszeit,",
    "von Null ab hoch. Der Ausgang der TOF Anweisung wird wahr, wenn die",
    "Zählervariable größer oder gleich der vorliegenden Verzögerung ist.",
    "Es möglich die Zählervariable an einer anderen Stelle im Programm zu",
    "bearbeiten, zum Beispiel mit einer TRANSFER-Anweisung (MOV).",
    "",
    "",
    "> SPEICHERNDER TIMER         Trto",
    "                      -[RTO 1.000 s]-",
    "",
    "Diese Anweisung zeichnet auf, wie lange sein Eingang ‘wahr’ gewesen",
    "ist. Wenn der Eingang für mindestens 1.000 s ‘wahr’ gewesen ist, dann",
    "wird der Ausgang ‘wahr’. Andernfalls ist er ‘unwahr’. Der Eingang muss",
    "für 1000 aufeinanderfolgende Millisekunden ‘wahr’ gewesen sein; wenn",
    "der Eingang für 0,6 s ‘wahr’ war, dann ‘unwahr’ für 2,0 s und danach für",
    "0,4 s  wieder ‘wahr’, so wird sein Ausgang ‘wahr’. Nachdem der Ausgang",
    "‘wahr’ wurde, so bleibt er ‘wahr’, selbst wenn der Eingang ‘unwahr’",
    "wird, so lange der Eingang für länger als 1.000 s ‘wahr’ gewesen ist.",
    "Der Timer muss deshalb von Hand mit Hilfe der Rücksetz-Anweisung",
    "rückgesetzt (auf Null gesetzt) werden.",
    "",
    "Die ‘TName’ Variable zählt, in der Einheit der jeweiligen Zykluszeit,",
    "von Null ab hoch. Der Ausgang der RTO-Anweisung wird wahr, wenn die",
    "Zählervariable größer oder gleich der vorliegenden Verzögerung ist.",
    "Es möglich die Zählervariable an einer anderen Stelle im Programm zu",
    "bearbeiten, zum Beispiel mit einer TRANSFER-Anweisung (MOV).",
    "",
    "",
    "> RÜCKSETZEN              Trto             Citems",
    "                     ----{RES}----     ----{RES}----",
    "",
    "Diese Anweisung rücksetzt einen Timer oder Zähler. TON oder TOF Timer",
    "werden automatisch rückgesetzt, wenn ihr Eingang ‘wahr’ oder ‘unwahr’",
    "wird, somit ist die RES-Anweisung für diese Timer nicht erforderlich. RTO",
    "Timer und CTU/CTD Zähler werden nicht automatisch rückgesetzt, somit",
    "müssen diese von Hand mit Hilfe der RES-Anweisung rückgesetzt (auf Null)",
    "werden. Wenn der Eingang ‘wahr’ ist, so wird der Timer oder Zähler",
    "rückgesetzt; wenn der Eingang ‘unwahr’ ist, so erfolgt keine Aktion.",
    "Diese Anweisung muss ganz rechts im Netzwerk stehen.",
    "",
    "                                               _",
    "> ONE-SHOT RISING, STEIGENDE FLANKE    --[OSR_/  ]--",
    "",
    "Diese Anweisung wird normalerweise ‘unwahr’ ausgewiesen. Wenn der Eingang",
    "der Anweisung während des momentanen Zyklus ‘wahr’ ist und während des",
    "vorgehenden ‘unwahr’ war, so wird der Ausgang ‘wahr’. Daher erzeugt diese",
    "Anweisung bei jeder steigenden Flanke einen Impuls für einen Zyklus.",
    "Diese Anweisung ist hilfreich, wenn Sie Ereignisse an der steigenden",
    "Flanke eines Signals auslösen wollen.",
    "",
    "                                             _",
    "> ONE-SHOT FALLING, FALLENDE FLANKE    --[OSF \\_  ]--",
    "",
    "Diese Anweisung wird normalerweise ‘unwahr’ ausgewiesen. Wenn der Eingang",
    "der Anweisung während des momentanen Zyklus ‘unwahr’ ist und während des",
    "vorgehenden ‘wahr’ war, so wird der Ausgang ‘wahr’. Daher erzeugt diese",
    "Anweisung bei jeder fallenden Flanke einen Impuls für einen Zyklus.",
    "Diese Anweisung ist hilfreich, wenn Sie Ereignisse an der fallenden",
    "Flanke eines Signals auslösen wollen.",
    "",
    "",
    "> BRÜCKE, ÖFFNUNG     ----+----+----      ----+     +----",
    "",
    "Der Eingangszustand einer Brücke ist immer gleich seinem Ausgangszustand.",
    "Der Ausgangszustands einer Öffnung ist immer ‘unwahr’. Diese Anweisungen",
    "sind bei der Fehlerbehebung (debugging) besonders hilfreich.",
    "",
    "",
    "> MASTER CONTROL RELAIS   -{MASTER RLY}-",
    "",
    "",
    "Im Normalfall ist der Anfang (die linke Stromschiene) von jedem Netzwerk",
    "‘wahr’. Wenn eine ‘Master Control Relais’ Anweisung ausgeführt wird dessen",
    "Eingang ‘unwahr’ ist, so werden die Anfänge (die linke Stromschiene)",
    "aller folgenden Netzwerke ‘unwahr’. Das setzt sich fort bis die nächste",
    "‘Master Control Relais’ Anweisung erreicht wird (unabhängig von dem",
    "Anfangszustand dieser Anweisung). Diese Anweisungen müssen daher als Paar",
    "verwendet werden: Eine (vielleicht abhängige), um den „gegebenenfalls",
    "gesperrten“ Abschnitt zu starten und eine weitere, um diesen zu beenden.",
    "",
    "",
    "> TRANSFER, MOV           {destvar :=  }      {Tret :=     }",
    "                         -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "Wenn der Eingang dieser Anweisung ‘wahr’ ist, so setzt diese die",
    "vorliegende Zielvariable gleich der vorliegenden Quellvariablen",
    "oder Konstanten. Wenn der Eingang dieser Anweisung ‘unwahr’ ist, so",
    "geschieht nichts. Mit der TRANSFER-Anweisung (MOV) können Sie jede",
    "Variable zuweisen; dies schließt Timer und Zähler Statusvariablen ein,",
    "welche mit einem vorgestellten ‘T’ oder ‘C’ unterschieden werden. Eine",
    "Anweisung zum Beispiel, die eine ‘0’ in einen ‘TBewahrend’ transferiert,",
    "ist äquivalent mit einer RES-Anweisung für diesen Timer. Diese Anweisung",
    "muss ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> ARITHMETISCHE OPERATIONEN   {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                             -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                             {MUL  dest :=}       {DIV  dv :=  }",
    "                             -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "Wenn der Eingang einer dieser Anweisungen ‘wahr’ ist, so setzt diese",
    "die vorliegende Zielvariable gleich dem vorliegenden arithmetischem",
    "Ausdruck. Die Operanden können entweder Variabelen (einschließlich Timer-",
    "und Zählervariabelen) oder Konstanten sein. Diese Anweisungen verwenden",
    "16-Bitzeichen Mathematik. Beachten Sie, dass das Ergebnis jeden Zyklus",
    "ausgewertet wird, wenn der Eingangszustand ‘wahr’ ist. Falls Sie eine",
    "Variable inkrementieren oder dekrementieren (d.h., wenn die Zielvariable",
    "ebenfalls einer der Operanden ist), dann wollen Sie dies vermutlich",
    "nicht; normalerweise würden Sie einen Impuls (one-shot) verwenden,",
    "sodass die Variable nur bei einer steigenden oder fallenden Flanke des",
    "Eingangszustands ausgewertet wird. Dividieren kürzt: D.h. 8 / 3 = 2.",
    "Diese Anweisungen müssen ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> VERGLEICHEN           [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]        [-4 <   ]      [1 <=]",
    "                       -[ var2 ]-      -[ vartwo]-    -[ Cup]-",
    "",
    "Wenn der Eingang dieser Anweisung ‘unwahr’ ist, so ist der Ausgang",
    "auch ‘unwahr’. Wenn der Eingang dieser Anweisung ‘wahr’ ist, dann ist",
    "Ausgang ‘wahr’; dies aber nur, wenn die vorliegende Bedingung ‘wahr’",
    "ist. Diese Anweisungen können zum Vergleichen verwendet werden, wie:",
    "Auf gleich, auf größer als, auf größer als oder gleich, auf ungleich,",
    "auf kleiner als, auf kleiner als oder gleich, eine Variable mit einer",
    "Variablen oder eine Variable mit einer 16-Bitzeichen-Konstanten.",
    "",
    "",
    "> ZÄHLER        CName          CName",
    "              --[CTU >=5]--  --[CTD >=5]—",
    "",
    "Ein Zähler inkrementiert (CTU, aufwärtszählen) oder dekrementiert",
    "(CTD, abwärtszählen) die bezogene Zählung bei jeder steigenden Flanke",
    "des Eingangszustands des Netzwerks (d.h. der Eingangszustand des",
    "Netzwerks geht von ‘unwahr’ auf ‘wahr’ über).  Der Ausgangszustand des",
    "Zählers ist ‘wahr’, wenn die Zähler- variable ist größer oder gleich 5",
    "und andernfalls ‘unwahr’. Der Ausgangszustand des Netzwerks kann ‘wahr’",
    "sein, selbst wenn der Eingangszustand ‘unwahr’ ist; das hängt lediglich",
    "von Zählervariablen ab. Sie können einer CTU- und CTD-Anweisung den",
    "gleichen Namen zuteilen, um den gleichen Zähler zu inkrementieren und",
    "dekrementieren. Die RES-Anweisung kann einen Zähler rücksetzen oder auch",
    "eine gewöhnliche Variablen-Operation mit der Zählervariablen ausführen.",
    "",
    "",
    "> ZIRKULIERENDER ZÄHLER       CName",
    "                          --{CTC 0:7}--",
    "",
    "Ein zirkulierender Zähler arbeitet wie ein normaler CTU-Zähler, außer",
    "nach der Erreichung seiner Obergrenze, rücksetzt er seine Zählervariable",
    "auf Null. Zum Beispiel würde der oben gezeigte Zähler, wie folgt zählen:",
    "0, 1, 2, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2,....  Dies ist",
    "hilfreich in Kombination mit bedingten Anweisungen der Variablen‘CName’;",
    "Sie können dies als eine Folgeschaltung verwenden. CTC-Zähler takten",
    "mit der aufsteigenden Flanke der Eingangsbedingung des Netzwerks.",
    "Diese Anweisung muss ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> SCHIEBEREGISTER          {SHIFT REG   }",
    "                          -{ reg0..3    }-",
    "",
    "Ein Schieberegister besteht aus einer Reihe von Variablen. So bestünde",
    "zum Beispiel ein Schieberegister aus den Variablen ‘reg0’, ‘reg1’,",
    "‘reg2’, and ‘reg3’. Der Eingang des Schieberegisters ist ‘reg0’. Bei",
    "jeder steigenden Flanke der Eingansbedingung des Netzwerks, schiebt das",
    "Schieberegister nach rechts. Dies bedeutet es wie folgt zuweist: ‘reg3’",
    "nach ‘reg2’, ‘reg2’ nach ‘reg1’ und ‘reg1’ nach ‘reg0’.  ‘reg0’ bleibt",
    "unverändert. Ein großes Schieberegister kann leicht viel Speicherplatz",
    "belegen. Diese Anweisung muss ganz rechts im Netzwerk stehen.",
    "",
    "",
    "> NACHSCHLAG-TABELLE       {dest :=     }",
    "                          -{ LUT[i]     }-",
    "",
    "Eine Nachschlag-Tabelle ist eine Anordnung von n Werten. Wenn die",
    "Eingangsbedingung des Netzwerks ‘wahr’ ist, so wird die Ganzzahl-Variable",
    "‘dest’ mit dem Eintrag in der Nachschlag-Tabelle gleichgesetzt, der der",
    "Ganzzahl-Variablen ‘i’ entspricht. Das Verzeichnis beginnt bei Null,",
    "insofern muss sich ‘i’ zwischen 0 und (n-1) befinden. Das Verhalten",
    "dieser Anweisung ist undefiniert, wenn sich die Werte des Verzeichnisses",
    "außerhalb dieses Bereichs befinden.",
    "",
    "",
    "> NÄHERUNGS-LINEAR-TABELLE    {yvar :=}",
    "                             -{PWL[xvar] }-",
    "",
    "Dies ist eine gute Methode für die Näherungslösung einer komplizierten",
    "Funktion oder Kurve. Sie könnte zum Beispiel hilfreich sein, wenn Sie",
    "versuchen eine Eichkurve zu verwenden, um die rohe Ausgangsspannung",
    "eines Fühlers in günstigere Einheiten zu wandeln.",
    "",
    "Angenommen Sie versuchen eine Näherungslösung für eine Funktion zu finden,",
    "die eine Eingangs-Ganzzahlvariable ‘x’ in Ausgangs-Ganzzahlvariable ‘y’",
    "wandelt. Einige Punkte der Funktion sind Ihnen bekannt; so würden Sie",
    "z.B. die folgenden kennen:",
    "",
    "    f(0)     = 2",
    "    f(5)     = 10",
    "    f(10)     = 50",
    "    f(100) = 100",
    "",
    "Dies bedeutet, dass sich die Punkte",
    "",
    "    (x0, y0)    = (  0,    2)",
    "    (x1, y1)    = (  5,   10)",
    "    (x2, y2)    = ( 10,   50)",
    "    (x3, y3)    = (100,  100)",
    "",
    "in dieser Kurve befinden. Diese 4 Punkte können Sie in die Tabelle der",
    "‘Näherungs-Linear’-Anweisung eintragen. Die ‘Näherungs-Linear’-Anweisung",
    "wird dann auf den Wert von ‘xvar’ schauen und legt den Wert von ‘yvar’",
    "fest. Sie stellt ‘yvar’ so ein, dass die ‘Näherungs-Linear’-Kurve sich",
    "durch alle Punkte bewegt, die Sie vorgegeben haben.  Wenn Sie z.B. für",
    "‘xvar’ = 10 vorgegeben haben, dann stellt die Anweisung ‘yvar’ auf gleich",
    "50 ein.",
    "",
    "Falls Sie dieser Anweisung einen Wert ‘xvar’ zuweisen, der zwischen zwei",
    "Werten von ‘x’ liegt, denen Sie Punkte zugeordnet haben, dann stellt die",
    "Anweisung ‘yvar’ so ein, dass (‘xvar’, ‘yvar’) in der geraden Linie liegt;",
    "diejenige die, die zwei Punkte in der Tabelle verbindet. Z.B. erzeugt",
    "‘xvar’ = 55 bei ‘yvar’ = 75. Die beiden Punkte in der Tabelle sind (10,",
    "50) und (100, 100). 55 liegt auf halbem Weg zwischen 10 und 100 und 75",
    "liegt auf halbem Weg zwischen 50 und 100, somit liegt (55, 75) auf der",
    "Linie, die diese zwei Punkte verbindet.",
    "",
    "Die Punkte müssen in aufsteigender Reihenfolge der x-Koordinaten",
    "angegeben werden. Einige mathematische Operationen, erforderlich für",
    "bestimmte Nachschlag-Tabellen mit 16-Bit-Mathematik, kann man ggf. nicht",
    "ausführen. In diesem Falle gibt POPTools eine Warnmeldung aus. So würde",
    "z.B. die folgende Nachschlag-Tabelle eine Fehlermeldung hervorrufen:",
    "",
    "    (x0, y0)    = (  0,    0)",
    "    (x1, y1)    = (300,  300)",
    "",
    "Sie können diesen Fehler beheben, indem sie den Abstand zwischen den",
    "Punkten kleiner machen. So ist zum Beispiel die nächste Tabelle äquivalent",
    "zur vorhergehenden, ruft aber keine Fehlermeldung hervor.",
    "",
    "    (x0, y0)    = (  0,    2)",
    "    (x1, y1)    = (150,  150)",
    "    (x2, y2)    = (300,  300)",
    "",
    "Es wird kaum einmal notwendig sein, mehr als fünf oder sechs Punkte",
    "zu verwenden. Falls Sie mehr Punkte hinzufügen, so vergrößert dies",
    "Ihren Code und verlangsamt die Ausführung. Falls Sie für ‘xvar’ einen",
    "Wert vergeben, der größer ist, als die größte x-Koordinate der Tabelle",
    "oder kleiner, als die kleinste x-Koordinate in der Tabelle, so ist das",
    "Verhalten der Anweisung undefiniert. Diese Anweisung muss ganz rechts",
    "im Netzwerk stehen.",
    "",
    "",
    "> A/D-WANDLER EINLESEN      AName",
    "                        --{READ ADC}--",
    "",
    "POPTools kann einen Code erzeugen, der ermöglicht, die A/D-Wandler",
    "zu verwenden, die in manchen Mikroprozessoren vorgesehen sind.",
    "Wenn der Eingangszustand dieser Anweisung ‘wahr’ ist, dann wird eine",
    "Einzellesung von dem A/D-Wandler entnommen und in der Variablen ‘AName’",
    "gespeichert. Diese Variable kann anschließend mit einer gewöhnlichen",
    "Ganzzahlvariablen bearbeitet werden (wie: Kleiner als, größer als,",
    "arithmetisch usw.). Weisen Sie ‘Axxx’ in der gleichen Weise einen Pin",
    "zu, wie Sie einen Pin für einen digitalen Ein- oder Ausgang vergeben",
    "würden, indem auf diesen in der Liste unten in der Maske (Bildanzeige)",
    "doppelklicken.  Wenn der Eingangszustand dieses Netzwerks ‘unwahr’ ist,",
    "so wird die Variable ‘AName’ unverändert belassen.",
    "",
    "Für alle derzeitig unterstützten Prozessoren gilt: Eine 0 Volt Lesung",
    "am Eingang des A/D-Wandlers entspricht 0. Eine Lesung gleich der",
    "Versorgungsspannung (bzw. Referenzspannung) entspricht 1023. Falls Sie",
    "AVR-Prozessoren verwenden, so verbinden Sie AREF mit Vdd.  (Siehe Atmel",
    "Datenblatt, dort wird eine Induktivität von 100µH empfohlen). Sie können",
    "arithmetische Operationen verwenden, um einen günstigeren Maßstabfaktor",
    "festzulegen, aber beachten Sie, dass das Programm nur Ganzzahl-Arithmetik",
    "vorsieht. Allgemein sind nicht alle Pins als A/D-Wandler verwendbar. Die",
    "Software gestattet Ihnen nicht, einen Pin zuzuweisen, der kein A/D",
    "bzw. analoger Eingang ist. Diese Anweisung muss ganz rechts im Netzwerk",
    "stehen.",
    "",
    "",
    "> PULSWEITEN MODULATIONSZYKLUS FESTLEGEN    duty_cycle",
    "                                          -{PWM 32.8 kHz}-",
    "",
    "POPTools kann einen Code erzeugen, der ermöglicht, die PWM-Peripherie",
    "zu verwenden, die in manchen Mikroprozessoren vorgesehen ist. Wenn die",
    "Eingangsbedingung dieser Anweisung ‘wahr’ ist, so wird der Zyklus der",
    "PWM-Peripherie mit dem Wert der Variablen ‘duty cycle’ gleichgesetzt. Der",
    "‘duty cycle’ muss eine Zahl zwischen 0 und 100 sein. 0 entspricht immer",
    "‘low’ und 100 entsprechend  immer ‘high’. (Wenn Sie damit vertraut sind,",
    "wie die PWM-Peripherie funktioniert, so bemerken Sie, dass dies bedeutet,",
    "dass POPTools die ‘duty cycle’-Variable automatisch prozentual zu den",
    "PWM-Taktintervallen skaliert [= den Maßstabfaktor festlegt].)",
    "",
    "Sie können die PWM-Zielfrequenz in Hz definieren. Es kann vorkommen, dass",
    "die angegebene Frequenz nicht genau erreicht wird, das hängt davon ab,",
    "wie sich diese innerhalb der Taktfrequenz des Prozessors einteilt. POPTools",
    "wählt dann die nächst erreichbare Frequenz; falls der Fehler zu groß ist,",
    "so wird eine Warnung ausgegeben. Höhere Geschwindigkeiten können die",
    "Auflösung beeinträchtigen.",
    "",
    "Diese Anweisung muss ganz rechts im Netzwerk stehen. Die ‘ladder",
    "logic’-Laufzeit verbraucht (schon) einen Timer, um die Zykluszeit",
    "zu messen. Dies bedeutet, dass die PWM nur bei den Mikroprozessoren",
    "verfügbar ist, bei denen mindestens zwei geeignete Timer vorhanden sind.",
    "PWM verwendet den PIN CCP2 (nicht CCP1) bei den PIC16-Prozessoren und",
    "OC2 (nicht OC1A) bei den AVR-Prozessoren.",
    "",
    "",
    "> REMANENT MACHEN     saved_var",
    "                    --{PERSIST}--",
    "",
    "Wenn der Eingangszustand dieser Anweisung ‘wahr’ ist, so bewirkt",
    "dies, dass eine angegebene Ganzzahl-Variable automatisch im EEPROM",
    "gespeichert wird. Dies bedeutet, dass ihr Wert bestehen bleiben wird,",
    "auch wenn der Prozessor seine Versorgungsspannung verliert. Es ist",
    "nicht notwendig, die Variable an klarer Stelle im EEPROM zu speichern,",
    "dies geschieht automatisch, so oft sich der Wert der Variablen",
    "ändert. Bei Spannungswiederkehr wird die Variable automatisch vom",
    "EEPROM zurückgespeichert. Falls eine Variable, die häufig ihren Wert",
    "ändert, remanent (dauerhaft) gemacht wird, so könnte Ihr Prozessor sehr",
    "rasch verschleißen, weil dieser lediglich für eine begrenzte Anzahl von",
    "Schreibbefehlen konstruiert ist (~100 000). Wenn der Eingangszustand des",
    "Netzwerks ‘unwahr’ ist, so geschieht nichts. Diese Anweisung muss ganz",
    "rechts im Netzwerk stehen.",
    "",
    "",
    "> UART (SERIELL) EMPFANGEN      var",
    "                            --{UART RECV}--",
    "",
    "POPTools kann einen Code erzeugen, der ermöglicht UART zu verwenden,",
    "welcher in manchen Mikroprozessoren vorgesehen ist.",
    "Bei AVR-Prozessoren mir mehrfachem UART, wird nur UART1 (nicht UART0)",
    "unterstützt. Konfigurieren Sie die Baudrate, indem Sie ‘Voreinstellungen",
    "-> Prozessor-Parameter’ verwenden. Bestimmte Baudraten werden mit",
    "bestimmten Quarzfrequenzen nicht erreichbar sein. In diesem Fall gibt",
    "POPTools eine Warnmeldung.",
    "",
    "Wenn der Eingangszustand dieser Anweisung ‘unwahr’ ist, so geschieht",
    "nichts. Wenn der Eingangszustand ‘wahr’ ist, so versucht diese Anweisung",
    "ein einzelnes Schriftzeichen vom UART-Eingang zu empfangen. Wenn",
    "kein Schriftzeichen eingelesen wird, dann ist der Ausgangszustand",
    "‘unwahr’. Wenn ein ASCII-Zeichen eingelesen wird, so wird sein Wert in",
    "‘var’ abgespeichert und der Ausgangszustand wird für einen einzelnen",
    "Zyklus ‘wahr’.",
    "",
    "",
    "> UART (SERIELL) SENDEN       var",
    "                          --{UART SEND}--",
    "",
    "POPTools kann einen Code erzeugen, der ermöglicht UART zu verwenden,",
    "welcher in manchen Mikroprozessoren vorgesehen ist.",
    "Bei AVR-Prozessoren mir mehrfachem UART, wird nur UART1 (nicht UART0)",
    "unterstützt. Konfigurieren Sie die Baudrate, indem Sie ‘Voreinstellungen",
    "-> Prozessor-Parameter’ verwenden. Bestimmte Baudraten werden mit",
    "bestimmten Quarzfrequenzen nicht erreichbar sein. In diesem Fall gibt",
    "POPTools eine Warnmeldung.",
    "",
    "Wenn der Eingangszustand dieser Anweisung ‘unwahr’ ist, so geschieht",
    "nichts. Wenn der Eingangszustand ‘wahr’ ist, so schreibt diese",
    "Anweisung ein einzelnes Schriftzeichen zum UART. Der ASCII-Wert des",
    "Schriftzeichens, welches gesendet werden soll, muss vorher in ‘var’",
    "abgespeichert worden sein. Der Ausgangszustand dieses Netzwerks ist",
    "‘wahr’, wenn UART beschäftigt ist (gerade dabei ein Schriftzeichen zu",
    "übermitteln) und andernfalls ‘unwahr’.",
    "",
    "Denken Sie daran, dass einige Zeit zum Senden von Schriftzeichen",
    "beansprucht wird. Überprüfen Sie den Ausgangszustand dieser Anweisung,",
    "sodass das erste Schriftzeichen bereits übermittelt wurde, bevor Sie",
    "versuchen ein zweites Schriftzeichen zu übermitteln. Oder verwenden Sie",
    "einen Timer, um eine Verzögerung zwischen die Schriftzeichen fügen. Sie",
    "dürfen den Eingangszustand dieser Anweisung nur dann auf ‘wahr’ setzen",
    "(bzw. ein Schriftzeichen übermitteln), wenn der Ausgangszustand ‘unwahr’",
    "ist (bzw. UART unbeschäftigt ist).",
    "",
    "Untersuchen Sie die “Formatierte Zeichenfolge”-Anweisung, bevor Sie",
    "diese Anweisung verwenden. Die “Formatierte Zeichenfolge”- Anweisung",
    "ist viel einfacher in der Anwendung und fast sicher fähig, das zu tun,",
    "was Sie beabsichtigen.",
    "",
    " ",
    "> FORMATIERTE ZEICHENFOLGE ÜBER UART            var",
    "                                        -{\"Druck: \\3\\r\\n\"}-",
    "",
    "POPTools kann einen Code erzeugen, der ermöglicht UART zu verwenden,",
    "welcher in manchen Mikroprozessoren vorgesehen ist.",
    "Bei AVR-Prozessoren mir mehrfachem UART, wird nur UART1 (nicht UART0)",
    "unterstützt. Konfigurieren Sie die Baudrate, indem Sie ‘Voreinstellungen",
    "-> Prozessor-Parameter’ verwenden. Bestimmte Baudraten werden mit",
    "bestimmten Quarzfrequenzen nicht erreichbar sein. In diesem Fall gibt",
    "POPTools eine Warnmeldung.",
    "",
    "Wenn der Eingangszustand des Netzwerks für diese Anweisung von ‘unwahr’",
    "auf ‘wahr’ übergeht, so beginnt diese eine vollständige Zeichenfolge",
    "über den seriellen Anschluss zu senden. Wenn die Zeichenfolge die",
    "besondere Reihenfolge ‘\\3’ enthält, dann wird diese Folge durch den Wert",
    "von ‘var’ ersetzt, welcher automatisch in eine Zeichenfolge gewandelt",
    "wird. Die Variable wird formatiert, sodass diese exakt 3 Schriftzeichen",
    "übernimmt. Falls die Variable zum Beispiel gleich 35 ist, dann wird die",
    "exakte ausgegebene Zeichenfolge, wie folgt aussehen: ‘Druck:  35\\r\\n’",
    "(beachten Sie das zusätzliche Freizeichen). Wenn stattdessen die Variable",
    "gleich 1432 ist, so wäre das Verhalten der Anweisung undefiniert,",
    "weil 1432 mehr als drei Stellen hat. In diesem Fall wäre es notwendig",
    "stattdessen ‘\\4’ zu verwenden.",
    "",
    "Falls die Variable negativ ist, so verwenden Sie stattdessen ‘\\-3d’",
    "(oder ‘\\-4d’). POPTools wird hierdurch veranlasst eine vorgestellte",
    "Freistelle für positive Zahlen und ein vorgestelltes Minuszeichen für",
    "negative Zahlen auszugeben.",
    "",
    "Falls mehrere “Formatierte Zeichenfolge”-Anweisungen zugleich ausgegeben",
    "werden (oder wenn eine neue Zeichenfolge ausgegeben wird bevor die",
    "vorherige vollendet ist), oder auch wenn diese mit UART TX Anweisungen",
    "vermischt, so ist das Verhalten undefiniert.",
    "",
    "Es ist auch möglich diese Anweisung für eine feste Zeichenfolge zu",
    "verwenden, die über den seriellen Anschluss gesendet wird, ohne den Wert",
    "einer Ganzzahlvariablen in den Text zu interpolieren. In diesem Fall",
    "fügen Sie einfach diese spezielle Steuerungsfolge nicht ein.",
    "",
    "Verwenden Sie ‘\\\\’ für einen zeichengetreuen verkehrten Schrägstrich.",
    "Zusätzlich zur Steuerungsfolge für die Interpolierung einer Ganzzahl-",
    "Variablen, sind die folgenden Steuerungszeichen erhältlich:",
    "",
    "        * \\r   -- carriage return      Zeilenschaltung",
    "        * \\n   -- new line             Zeilenwechsel",
    "        * \\f   -- form feed            Formularvorschub",
    "        * \\b   -- backspace            Rücksetzen",
    "        * \\xAB -- character with ASCII value 0xAB (hex)",
    "               -- Schriftzeichen mit ASCII-Wert 0xAB (hex)",
    "",
    "Der Ausgangszustand des Netzwerks dieser Anweisung ist ‘wahr’, während",
    "diese Daten überträgt, ansonsten ‘unwahr’. Diese Anweisung benötigt eine",
    "große Menge des Programmspeichers, insofern sollte sie sparsam verwendet",
    "werden. Die gegenwärtige Umsetzung ist nicht besonders effizient, aber",
    "eine bessere würde Änderungen an sämtlichen Ausläufern des Programms",
    "benötigen.",
    "",
    "",
    "EIN HINWEIS ZUR VERWENDUNG DER MATHEMATIK",
    "=========================================",
    "",
    "Denken Sie daran, dass POPTools nur 16-Bit mathematische Operationen",
    "ausführt. Dies bedeutet, dass das Endresultat jeder Berechnung,",
    "die Sie vornehmen, eine Ganzzahl zwischen -32768 und 32767 sein muss.",
    "Dies bedeutet auch, dass die Zwischenergebnisse Ihrer Berechnungen alle",
    "in diesem Bereich liegen müssen.",
    "",
    "Wollen wir zum Beispiel annehmen, dass Sie folgendes berechnen möchten",
    "y = (1/x) * 1200, in der x zwischen 1 und 20 liegt.",
    "Dann liegt y zwischen 1200 und 60, was in eine 16-Bit Ganzzahl passt,",
    "so wäre es zumindest theoretisch möglich diese Berechnung auszuführen.",
    "Es gibt zwei Möglichkeiten, wie Sie dies codieren könnten: Sie können",
    "die Reziproke (Kehrwert) ausführen and dann multiplizieren:",
    "",
    "   ||         {DIV  temp  :=}          ||",
    "   ||---------{ 1 / x       }----------||",
    "   ||                                  ||",
    "   ||          {MUL  y  :=  }          ||",
    "   ||----------{ temp * 1200}----------||",
    "   ||                                  ||",
    "",
    "Oder Sie könnten einfach die Division in einem Schritt direkt vornehmen.",
    "",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ 1200 / x }-----------||",
    "",
    "",
    "Mathematisch sind die zwei äquivalent; aber wenn Sie diese ausprobieren,",
    "so werden Sie herausfinden, dass die erste ein falsches Ergebnis von",
    "y = 0 liefert. Dies geschieht, weil die Variable einen Unterlauf",
    "[= resultatabhängige Kommaverschiebung] ergibt.  So sei zum Beispiel x = 3,",
    "(1 / x) = 0.333, dies ist aber keine Ganzzahl; die Divisionsoperation",
    "nähert dies, als 'temp = 0'. Dann ist y = temp * 1200 = 0. Im zweiten",
    "Fall gibt es kein Zwischenergebnis, welches einen Unterlauf [= resultats-",
    "abhängige Kommaverschiebung] ergibt, somit funktioniert dann alles.",
    "",
    "Falls Sie Probleme bei Ihren mathematischen Operationen erkennen,",
    "dann überprüfen Sie die Zwischenergebnisse auf Unterlauf [eine",
    "resultatabhängige Kommaverschiebung] (oder auch auf Überlauf, der dann",
    "im Programm in Umlauf kommt; wie zum Beispiel 32767 + 1 = -32768).",
    "Wann immer möglich, wählen Sie Einheiten, deren Werte in einem Bereich",
    "von -100 bis 100 liegen.",
    "",
    "Falls Sie eine Variable um einen bestimmten Faktor vergrößern müssen, tun",
    "Sie dies, indem Sie eine Multiplikation und eine Division verwenden. Um",
    "zum Beispiel y = 1.8 * x zu vergrößern, berechnen Sie y = (9/5) * x,",
    "(was dasselbe ist, weil 1,8 = 9/5 ist), und codieren Sie dies als",
    "y = (9 * x)/5, indem Sie die Multiplikation zuerst ausführen.",
    "",
    "   ||         {MUL  temp  :=}          ||",
    "   ||---------{ x * 9       }----------||",
    "   ||                                  ||",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ temp / 5 }-----------||",
    "",
    "",
    "Dies funktioniert mit allen x < (32767 / 9), oder x < 3640.  Bei höheren",
    "Werten würde die Variable ‘temp’ überfließen. Für x gibt es eine",
    "ähnliche Untergrenze.",
    "",
    "",
    "KODIER-STIL",
    "===========",
    "",
    "Ich gestatte mehrere Spulen in Parallelschaltung in einem einzigen",
    "Netzwerk unterzubringen. Das bedeutet, sie können ein Netzwerk, wie",
    "folgt schreiben:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    "   ||-------] [------+-------( )-------||",
    "   ||                |                 ||",
    "   ||                |       Yc        ||",
    "   ||                +-------( )-------||",
    "   ||                                  ||",
    " ",
    "Anstatt diesem:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    " 2 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yc        ||",
    " 3 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "",
    "Rein theoretisch bedeutet das, dass Sie irgendein Programm, als ein",
    "gigantisches Netzwerk, schreiben könnten. Und es bestünde überhaupt",
    "keine Notwendigkeit mehrere Netzwerke zu verwenden. In der Praxis ist",
    "dies aber eine schlechte Idee, denn wenn Netzwerke komplexer werden, so",
    "werden sie auch schwieriger zu editieren, ohne Löschen und neu Schreiben",
    "von Anweisungen.",
    "",
    "Jedoch, ist es manchmal ein guter Einfall, verwandte Logik in einem",
    "einzelnen Netzwerk zusammenzufassen. Dies erzeugt einen beinahe",
    "identischen Code, als ob sie getrennte Netzwerke entworfen hätten, es",
    "zeigt aber, dass diese Anweisungen (Logik) verwandt ist, wenn man diese",
    "im Netzwerk-Diagramm betrachtet.",
    "",
    "            *                *                *",
    "",
    "Im Allgemeinen hält man es für eine schlechte Form, den Code in einer",
    "solchen Weise zu schreiben, dass sein Ergebnis von einer Folge von",
    "Netzwerken abhängt. So zum Beispiel ist der folgende Code nicht besonders",
    "gut, falls ‘xa’ und ‘xb’ jemals ‘wahr’ würden.",
    "",
    "   ||       Xa         {v  :=       }  ||",
    " 1 ||-------] [--------{ 12      MOV}--||",
    "   ||                                  ||",
    "   ||       Xb         {v  :=       }  ||",
    "   ||-------] [--------{ 23      MOV}--||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||      [v >]             Yc        ||",
    " 2 ||------[ 15]-------------( )-------||",
    "   ||                                  ||",
    "",
    "Ich werde diese Regel brechen und indem ich dies so mache, entwerfe ich",
    "einen Code-Abschnitt, der erheblich kompakter ist. Hier zum Beispiel,",
    "zeige ich auf, wie ich eine 4-Bit binäre Größe von ‘xb3:0’ in eine",
    "Ganzzahl wandeln würde.",
    "",
    "   ||                                   {v  :=       }  ||",
    " 3 ||-----------------------------------{ 0       MOV}--||",
    "   ||                                                   ||",
    "   ||       Xb0                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 1    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb1                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 2    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb2                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 4    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb3                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 8    }-----------||",
    "   ||                                                   ||",
    "",
    "Falls die TRANSFER-Anweisung (MOV) an das untere Ende des Netzwerks",
    "gebracht würde, anstatt auf das obere, so würde der Wert von ‘v’, an",
    "anderer Stelle im Programm gelesen, gleich Null sein. Das Ergebnis dieses",
    "Codes hängt daher von der Reihenfolge ab, in welcher die Anweisungen",
    "ausgewertet werden.  Im Hinblick darauf, wie hinderlich es wäre, diesen",
    "Code auf eine andere Weise zu schreiben, nehme ich dies so hin.",
    "",
    "",
    "BUGS",
    "====",
    "",
    "POPTools erzeugt keinen sehr effizienten Code; es ist langsam in der",
    "Ausführung und geht verschwenderisch mit dem Flash- und RAM-Speicher",
    "um. Trotzdem kann ein mittelgroßer PIC- oder AVR-Prozessor alles, was",
    "eine kleine SPS kann, somit stört dies mich nicht besonders.",
    "",
    "Die maximale Länge der Variabelen-Bezeichnungen (-Namen) ist sehr",
    "begrenzt. Dies ist so, weil diese so gut in das KOP-Programm (ladder)",
    "passen. Somit sehe ich keine gute Lösung für diese Angelegenheit.",
    "",
    "Falls Ihr Programm zu groß für die Zeit-, Programmspeicher- oder",
    "Datenspeicher-Beschränkungen des Prozessors ist, den Sie gewählt haben,",
    "so erhalten Sie keine Fehlermeldung. Es wird einfach irgendwo anders alles",
    "vermasseln. (Anmerkung: Das AVR STK500 gibt hierzu Fehlermeldungen aus.)",
    "",
    "Unsorgfältiges Programmieren bei den Datei Öffnen/Abspeichern-Routinen",
    "führen wahrscheinlich zu der Möglichkeit eines Absturzes oder es wird",
    "ein willkürlicher Code erzeugt, der eine beschädigte oder bösartige .ld",
    "Datei ergibt.",
    "",
    "Bitte berichten Sie zusätzliche Bugs oder richten Sie Anfragen für neue",
    "Programm-Bestandteile an den Autor (in Englisch).",
    "",
    "Thanks to:",
    "    * Marcelo Solano, for reporting a UI bug under Win98",
    "    * Serge V. Polubarjev, for not only noticing that RA3:0 on the",
    "      PIC16F628 didn't work but also telling me how to fix it",
    "    * Maxim Ibragimov, for reporting and diagnosing major problems",
    "      with the till-then-untested ATmega16 and ATmega162 targets",
    "    * Bill Kishonti, for reporting that the simulator crashed when the",
    "      ladder logic program divided by zero",
    "    * Mohamed Tayae, for reporting that persistent variables were broken",
    "      on the PIC16F628",
    "    * David Rothwell, for reporting several user interface bugs and a",
    "      problem with the \"Export as Text\" function",
    "",
    "Particular thanks to Heinz Ullrich Noell, for this translation (of both",
    "the manual and the program's user interface) into German.",
    "",
    "",
    "COPYING, AND DISCLAIMER",
    "=======================",
    "",
    "DO NOT USE CODE GENERATED BY POPTools IN APPLICATIONS WHERE SOFTWARE",
    "FAILURE COULD RESULT IN DANGER TO HUMAN LIFE OR DAMAGE TO PROPERTY. THE",
    "AUTHOR ASSUMES NO LIABILITY FOR ANY DAMAGES RESULTING FROM THE OPERATION",
    "OF POPTools OR CODE GENERATED BY POPTools.",
    "",
    "This program is free software: you can redistribute it and/or modify it",
    "under the terms of the GNU General Public License as published by the",
    "Free Software Foundation, either version 3 of the License, or (at your",
    "option) any later version.",
    "",
    "This program is distributed in the hope that it will be useful, but",
    "WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY",
    "or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License",
    "for more details.",
    "",
    "You should have received a copy of the GNU General Public License along",
    "with this program. If not, see <http://www.gnu.org/licenses/>.",
    "",
    "",
    "Jonathan Westhues",
    "",
    "Rijswijk      -- Dec 2004",
    "Waterloo ON   -- Jun, Jul 2005",
    "Cambridge MA  -- Sep, Dec 2005",
    "                 Feb, Mar 2006",
    "",
    "Email: user jwesthues, at host cq.cx",
    "",
    "",
    NULL
};
#endif

#ifdef LDLANG_FR
char *HelpTextFr[] = {
    "INTRODUCTION",
    "============",
    "",
    "POPTools génére du code natif pour certains microcontroleurs Microchip",
    "PIC16F et Atmel AVR. Usuellement les programmes de developpement pour ces",
    "microcontrolleurs sont écrits dans des langages comme l'assembleur , le",
    "C ou le Basic. Un programme qui utilise un de ces langages est une suite",
    "de commandes. Ces programmes sont puissants et adaptés à l'architecture",
    "des processeurs, qui de façon interne exécutent une liste d'instructions.",
    "",
    "Les API (Automates Programmables Industriels, PLC en anglais, SPS en",
    "allemand) utilisent une autre voie et sont programmés en Langage à",
    "Contacts (ou LADDER). Un programme simple est représenté comme ceci :",
    "",
    "",
    "   ||                                                                    ||",
    "   ||    Xbutton1           Tdon           Rchatter           Yred       ||",
    " 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||",
    "   ||                                 |                                  ||",
    "   ||    Xbutton2           Tdof      |                                  ||",
    "   ||-------]/[---------[TOF 2.000 s]-+                                  ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||    Rchatter            Ton             Tnew           Rchatter     ||",
    " 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||------[END]---------------------------------------------------------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "",
    "(TON est une tempo travail; TOF est une tempo repos. les commandes --] [-- ",
    "représentent des Entrées, qui peuvent être des contacts de relais. Les ",
    "commandes --( )-- sont des Sorties, qui peuvent représenter des bobines de ",
    "relais. Beaucoup de références de programmes de langage à contacts (LADDER) ",
    "existent sur Internet et sont à quelques détails près, identiques à ",
    "l'implémentation représentée ci-dessus.",
    "",
    "Un certain nombre de différences apparaissent entre les programmes en",
    "langage évolués ( C, Basic, Etc..) et les programmes pour API:",
    "",
    "    * Le programme est représenté dans un format graphique, et non",
    "      comme une liste de commandes en format texte. Beaucoup de personnes",
    "      trouve cela plus facile à comprendre.",
    "",
    "    * Au niveau de base, le programme apparait comme un diagramme",
    "      de circuit avec des contacts de relais (Entrées) et des bobines",
    "      (Sorties). Ceci est intuitif pour les programmeurs qui connaissent",
    "      la théorie des circuits électriques.",
    "",
    "    * Le compilateur de langage à contacts vérifie tout ceci lors",
    "      de la compilation. Vous n'avez pas à écrire de code quand une",
    "      Sortie est remplacée et est remise en Entrée ou si une temporisation",
    "      est modifiée, vous n'avez pas non plus à spécifier l'ordre où les",
    "      calculs doivent être effectués. L'outil API (PLC) s'occupe de cela",
    "      pour vous.",
    "",
    "",
    "POPTools compile le langage à contact (ladder) en code pour PIC16F ou",
    "AVR. Les processeurs suivants sont supportés:",
    "",
    "    * PIC16F877",
    "    * PIC16F628",
    "    * PIC16F876 (non testé)",
    "    * PIC16F88  (non testé)",
    "    * PIC16F819 (non testé)",
    "    * PIC16F887 (non testé)",
    "    * PIC16F886 (non testé)",
    "    * ATmega128",
    "    * ATmega64",
    "    * ATmega162 (non testé)",
    "    * ATmega32  (non testé)",
    "    * ATmega16  (non testé)",
    "    * ATmega8   (non testé)",
    "",
    "Il doit être facile de supporter d'autres PIC ou AVR, mais je n'est",
    "aucun moyen pour les tester. Si vous en voulez un en particulier faites",
    "moi parvenir votre demande et je verrai ce que je peux faire.",
    "",
    "En utilisant POPTools, vous dessinez un diagramme à contacts pour votre",
    "programme. Vous pouvez simuler le fonctionnement logique en temps réel sur",
    "votre PC. Quand vous êtes convaincu que le fonctionnement est correct,",
    "vous pouvez affecter les broches du microcontroleur pour les Entrées et",
    "Sorties, ensuite vous compilez votre programmeen code AVR ou PIC. Le",
    "fichier de sortie du compilateur est un fichier .HEX que vous devrez",
    "mettre dans le microcontroleur en utilisant un programmateur pour PIC",
    "ou AVR.",
    "",
    "",
    "POPTools est conçu pour être similaire à la majorité des API commerciaux.",
    "Il y a quelques exceptions, et une partie des possibilités n'est",
    "pas standard avec le matériel industriel. Lire attentivement la",
    "description de chaque instruction même si elle parait familière. Ce",
    "document considère que vous avez une connaisance de base du langage à",
    "contact et de la structure des logiciels pour automates programmables.",
    "Cycle d'exécution : Lecture des Entrées -> Calculs -> Ecriture des Sorties",
    "",
    "",
    "CIBLES ADDITIONNELLES ",
    "=====================",
    "",
    "Il est aussi possible de générer du code ANSI C . Vous pouvez utiliser",
    "ceci pour n'importe quel processeur dont vous avez un compilateur C,",
    "mais le runtime est de votre responsabilité. POPTools gérére uniquement",
    "le source pour le cycle de l'API. Vous êtes responsable de l'appel de",
    "chaque séquence du cycle et de l'implémentation de toutes les Entrées",
    "/ Sorties (Lecture/Ecriture des Entrées digitales, etc ...). Voir les",
    "commentaires dans le code source pour plus de détails.",
    "",
    "Finalement, POPTools peut générer un code byte indépendant du processeur",
    "pour une machine virtuelle prévue pour faire fonctionner ce type de code.",
    "J'ai prévu un exemple simple d'implémentation d'un interpréteur /VM",
    "écrit en code C le plus portable possible.  La cible fonctionne juste sur",
    "quelques plateformes ou vous pouvez prévoir votre VM. Ceci peut être utile",
    "pour des applications ou vous pouvez utiliser le languages à contacts",
    "comme du langage script pour customiser un programme important. Voir",
    "les commentaires dans l'exemple pour les détails.",
    "",
    "",
    "OPTIONS LIGNE DE COMMANDE",
    "=========================",
    "",
    "POPTools.exe fonctionne normallement sans options de ligne de commande.",
    "Vous pouvez faire un raccourci vers le programme et le sauvegarder sur",
    "l'écran , il suffit alors de faire un double clic pour le faire démarrer",
    "et vous vous retrouvez ainsi dans l'interface utilisateur.",
    "",
    "Si un nom de fichier est passé en ligne de de commande de POPTools, (ex:",
    "`POPTools.exe asd.ld'), alors POPTools va essayer d'ouvrir `asd.ld', si",
    "il existe. Une erreur se produira si `asd.ld' n'existe pas. Vous avez",
    "la possibilité d'associer POPTools avec les fichiers d'extention .ld.",
    "Ceci permet à POPTools de démarrer automatiquement lors d'un double clic",
    "sur un fichier  xxx.ld.",
    "",
    "Si les arguments de la ligne de commande sont passés sous la forme:",
    "`POPTools.exe /c src.ld dest.hex', POPTools compilera le programme`src.ld',",
    "et sauvegardera le fichier compilé sous`dest.hex'. Après compilation",
    "POPTools se termine, que la compilation soit correcte ou pas. Aucun",
    "message n'est affiché sur la console. Ce mode est pratique uniquement",
    "lorsque vous exécutez POPTools en ligne de commande.",
    "",
    "",
    "BASES",
    "=====",
    "",
    "Si vous exécutez POPTools sans arguments de ligne de commande, il démarre",
    "avec un programme vide. Si vous démarrer avec le nom d'un programme",
    "langage à contacts (xxx.ld) en ligne de commande, il va essayer de",
    "charger le programme au démarrage. POPTools utilise son format interne",
    "pour le programme , il ne peut pas importer de programmes édités par",
    "d'autres outils.",
    "",
    "Si vous ne chargez pas un programme existant, POPTools démarre en insérant",
    "une ligne vide. Vous pouvez ajouter les instructions pour votre programme:",
    "par exemple ajouter un jeu de contacts (Instruction -> Insérer Contact)",
    "qui sera nommé `Xnew'. `X' désigne un contact qui peut être lié à une",
    "broche d'entrée du microcontroleur, vous pouvez affecter la broche pour",
    "ce contact plus tard après avoir choisi le microcontroleur et renommé",
    "les contacts. La première lettre indique de quel type de composants il",
    "s'agit par exemple :",
    "",
    "    * Xnom  -- Relié à une broche d'entrée du microcontroleur",
    "    * Ynom  -- Relié à une broche de sortie du microcontroleur",
    "    * Rnom  -- `Relais interne': un bit en mémoire",
    "    * Tnom  -- Temporisation; Tempo travail, tempo repos, ou totalisatrice",
    "    * Cnom  -- Compteur, Compteur ou décompteur",
    "    * Anom  -- Un entier lu sur un comvertisseur A/D ",
    "    * nom   -- Variable générique (Entier : Integer)",
    "",
    "Choisir le reste du nom pour décrire l'utilisation de ce que fait cet",
    "objet et qui doit être unique dans tout le programme. Un même nom doit",
    "toujours se référer au même objet dans le programme en entier.Par",
    "exemple , vous aurez une erreur si vous utilisez une tempo travail",
    "(TON) appellée TDelai et une tempo repos (TOF) appellée aussi TDelai",
    "dans le même programme, le comptage effectué par ces tempo utilisera le",
    "même emplacement en mémoire, mais il est acceptable d'avoir une tempo",
    "sauvegardée (RTO) Tdelai même nom avec une instruction de RES, dans ce",
    "cas l'instruction fonctionne avec le même timer.",
    "",
    "Les noms de variables peuvent être des lettres, chiffres ou le",
    "caractère _.  Un nom de variable ne doit pas commencer par un chiffre.",
    "Les noms de variables sont sensibles à la casse (majuscule/minuscules).",
    "",
    "Les instructions de manipulation de variables (MOV, ADD, EQU,",
    "etc.) peuvent travailler avec des variables de n'importe quel nom. Elles",
    "peuvent avoir accès aux accumulateurs des temporisations ou des",
    "compteurs. Cela peut quelquefois être très utile, par exemple si vous",
    "voulez contrôler la valeur d'un compteur ou d'une temporisation dans",
    "une ligne particulière.",
    "",
    "Les variables sont toujours des entiers 16 bits. Leur valeur peut",
    "donc être comprise entre -32768 et 32767 inclus. Les variables sont",
    "toujours signées.  Vous pouvez les spécifier de façon littérale comme",
    "des nombres décimaux normaux (0, 1234, -56), vous pouvez aussi les",
    "spécifier en caractères ASCII ('A', 'z') en mettant le caractère entre",
    "des guillemets simples. Vous pouvez utiliser un caractère ASCII dans la",
    "majorité des endroits où vous pouvez utiliser les nombres décimaux.",
    "",
    "En bas de l'écran, vous pouvez voir la liste de tous les objets",
    "utilisés dans votre programme. La liste est automatiquement générée",
    "à partir du programme.  La majorité des objets ne necessitent aucune",
    "configuration. Seuls : les objets `Xnom', `Ynom', and `Anom' doivent être",
    "affectés à une broche du micro La première chose à faire est de choisir",
    "la microcontroleur utilisé : Paramères -> Microcontroleur ensuite vous",
    "affectez les broches en faisant un double clic dans la liste.",
    "",
    "Vous pouvez modifier le programme en insérant ou supprimant des",
    "instructions.  Le curseur clignote dans la programme pour indiquer",
    "l'instruction courante sélectionnée et le point d'insertion. S'il ne",
    "clignote pas pressez <Tab> ou cliquer sur une instruction, ou vous",
    "pouvez insérer une nouvelle instruction à la droite ou à la gauche",
    "(en série avec), ou au dessous ou au dessus (en parallèle avec) de",
    "l'instruction sélectionnée. Quelques opérations ne sont pas permises ,",
    "par exemple aucune instruction permise à droite de la bobine.",
    "",
    "Le programme démarre avec uniquement une ligne. Vous pouvez ajouter",
    "plusieurs lignes en sélectionnant Insertion -> Ligne avant ou après",
    "dans le menu. Vous pouvez faire un circuit complexe en plaçant plusieurs",
    "branches en parallèle ou en série avec une ligne, mais il est plus clair",
    "de faire plusieurs lignes.",
    "",
    "Une fois votre programme écrit, vous pouvez le tester par simulation,",
    "et le compiler dans un fichier HEX pour le microcontroleur de destination.",
    "",
    "SIMULATION",
    "==========",
    "",
    "Pour entrer dans la mode simulation choisir Simulation -> Simuler",
    "ou presser <Ctrl+M> le programme est affiché différemment en mode",
    "simulation. Les instructions activées sont affichées en rouge vif, les",
    "instructions qui ne le sont pas sont affichées en grisé. Appuyer sur la",
    "barre d'espace pour démarrer l'API pour 1 cycle. Pour faire fonctionner",
    "continuellement en temps réel choisir Simulation ->Démarrer la simulation",
    "en temps réel ou presser <Ctrl+R> L'affichage du programme est mise à",
    "jour en temps réel en fonction des changements d'état des entrées.",
    "",
    "Vous pouvez valider l'état des entrées du programme en faisant un",
    "double clic sur l'entrée dans la liste au bas de l'écran, ou sur le",
    "contact `Xnom' de l'instruction dans le programme, pour avoir le reflet",
    "automatiquement de la validation d'une entrée dans le programme, il",
    "faut que le programme soit en cycle.(le démarrer par <Ctrl+R> ou barre",
    "d'espace pour un seul cycle).",
    "",
    "COMPILER EN CODE NATIF",
    "======================",
    "",
    "Le point final est de générer un fichier .HEX qui sera programmé dans le",
    "microcontroleur que vous avez choisi par Paramètres -> Microcontroleur",
    "Vous devez affecter les broches d'entrées sorties pour chaque 'Xnom'",
    "et 'Ynom'. Vous pouvez faire cela en faisant un double clic sur la nom",
    "de l'objet dans la liste au bas de l'écran. Une boite de dialogue vous",
    "demande de choisir une des broches non affectées dans la liste.",
    "",
    "Vous devez aussi choisir la temps de cycle que voulez utiliser pour",
    "votre application, vous devez aussi choisir la fréquence d'horloge du",
    "processeur.  Faire Paramètres -> Paramètres MCU dans le menu. En général,",
    "le temps de cycle peut être laissé à la valeur par défaut (10 ms) qui est",
    "une bonne valeur pour la majorité des applications. Indiquer la fréquence",
    "du quartz utilisé (ou du résonateur céramique ou autres..) et cliquer OK.",
    "",
    "Maintenant vous pouvez créer le fichier pour intégrer dans le",
    "microcontroleur. Choisir  Compilation -> Compiler, ou compiler sous...",
    "Si vous avez précédemment compilé votre programme, vous pouvez spécifier",
    "un nom différent de fichier de sortie. Si votre programme ne comporte",
    "pas d'erreur (lié à la structure du programme), POPTools génére un fichier",
    "IHEX prêt à être programmé dans le chip.",
    "",
    "Utilisez votre logiciel et matériel de programmation habituel pour",
    "charger le fichier HEX dans la microcontroleur. Vérifiez et validez",
    "les bits de configuration (fuses), pour les processeurs PIC16Fxxx ces",
    "bits sont inclus dans le fichier HEX, et la majorité des logiciels de",
    "programmation les valident automatiquement, pour les processeurs AVR ,",
    "vous devez le faire manuellement.",
    "",
    "REFERENCE DES INSTRUCTIONS ",
    "==========================",
    "",
    "> CONTACT, NORMALLEMENT OUVERT  Xnom            Rnom          Ynom",
    "                            ----] [----     ----] [----    ----] [----",
    "",
    "    Si le signal arrivant à cette instruction est FAUX (0) le signal",
    "    de sortie est aussi faux (0), s'il est vrai , il sera aussi vrai",
    "    en sortie si et uniquement si la broche d'Entrée ou de Sortie",
    "    ou de Relais interne est vraie, sinon l'instruction sera fausse.",
    "    Cette instruction peut vérifier l'état d'une broche d'entrée, d'une",
    "    broche de sortie ou d'un relais interne",
    "",
    " ",
    "> CONTACT, NORMALLEMENT FERME    Xnom            Rnom          Ynom",
    "                             ----]/[----     ----]/[----    ----]/[----",
    "",
    "    Si le signal arrivant à cette instruction est FAUX (0) le signal",
    "    de sortie est vrai (1), s'il est vrai , il sera faux en sortie .",
    "    Cette instruction peut vérifier l'état d'une broche d'entrée, d'une",
    "    broche de sortie ou d'un relais interne. Fonctionne en opposition",
    "    par rapport au contact normallement ouvert.",
    "",
    "",
    "> BOBINE, NORMALE                Rnom           Ynom",
    "                             ----( )----     ----( )----",
    "",
    "    Si le signal arrivant à cette instruction est faux, alors le relais ",
    "    interne ou la broche de sortie est faux (mise à zéro). Si le signal",
    "    arrivant à cette instruction est vrai(1), alors le relais interne ou",
    "    la broche de sortie est validée (mise à 1). Il n'est pas important",
    "    d'affecter une variable à une bobine.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "    ",
    "",
    "> BOBINE, INVERSE                Rnom         Ynom",
    "                             ----(/)----     ----(/)----",
    "",
    "    Si le signal arrivant à cette instruction est vrai, alors le relais ",
    "    interne ou la broche de sortie est faux (mise à zéro). Si le signal",
    "    arrivant à cette instruction est faux(0), alors le relais interne ou",
    "    la broche de sortie est validée (mise à 1). Il n'est pas important ",
    "    d'affecter une variable à une bobine.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "",
    "",
    "> BOBINE, ACCROCHAGE             Rnom           Ynom",
    "                             ----(S)----     ----(S)----",
    "",
    "    Si le signal arrivant à cette instruction est vrai, alors le",
    "    relais interne ou la broche de sortie est validée (mise à 1). Cette",
    "    instruction permet de changer l'état d'un relais ou d'une sortie :",
    "    uniquement passe à vrai, ou reste vrai si elle était déjà à 1,",
    "    elle est typiquement utilisée en combinaison avec une Bobine REMISE",
    "    A ZERO.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "",
    "",
    "> BOBINE, REMISE A ZERO          Rnom           Ynom",
    "                             ----(R)----     ----(R)----",
    "",
    "    Si le signal arrivant à cette instruction est vrai, alors le relais ",
    "    interne ou la sortie est mise à zéro (0), si elle était déjà à 0, ",
    "    il n'y a aucun changement, cette instruction change l'état d'une ",
    "    sortie uniquement si elle était à 1, cette instruction fonctionne en ",
    "    combinaison avec l'instruction ci-dessus Bobine à ACCROCHAGE.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "",
    "",
    "> TEMPORISATION TRAVAIL         Tdon ",
    "                           -[TON 1.000 s]-",
    "",
    "    Quand la signal arrivant à cette instruction passe de faux à vrai",
    "    (0 à 1), le signal de sortie attend 1.000 seconde avant de passer",
    "    à 1. Quand le signal de commande de cette instruction passe ZERO,",
    "    le signal de sortie passe immédiatement à zéro. La tempo est remise",
    "    à zéro à chaque fois que l'entrée repasse à zéro. L'entrée doit être",
    "    maintenue vraie à 1 pendant au moins 1000 millisecondes consécutives",
    "    avant que la sortie  ne devienne vraie. le délai est configurable.",
    "",
    "    La variable `Tnom' compte depuis zéro en unités de temps de scan.",
    "    L'instruction Ton devient vraie en sortie quand la variable du",
    "    compteur est plus grande ou égale au delai fixé. Il est possible",
    "    de manipuler la variable du compteur en dehors, par exemple par une",
    "    instruction MOVE.",
    "",
    "",
    "> TEMPORISATION REPOS           Tdoff ",
    "                           -[TOF 1.000 s]-",
    "",
    "    Quand le signal qui arrive à l'instruction passe de l'état vrai",
    "    (1) à l'état faux (0), la sortie attend 1.000 s avant de dévenir",
    "    faux (0) Quand le signal arrivant à l'instruction passe de l'état",
    "    faux à l'état vrai, le signal passe à vrai immédiatement. La",
    "    temporisation est remise à zéro à chaque fois que l'entrée devient",
    "    fausse. L'entrée doit être maintenue à l'état faux pendant au moins",
    "    1000 ms consécutives avant que la sortie ne passe à l'état faux. La",
    "    temporisation est configurable.",
    "",
    "    La variable `Tname' compte depuis zéro en unités de temps de scan.",
    "    L'instruction Ton devient vraie en sortie quand la variable du",
    "    compteur est plus grande ou égale au delai fixé. Il est possible",
    "    de manipuler la variable du compteur en dehors, par exemple par une",
    "    instruction MOVE.",
    "",
    "",
    "> TEMPORISATION TOTALISATRICE           Trto  ",
    "                                   -[RTO 1.000 s]-",
    "",
    "    Cette instruction prend en compte le temps que l'entrée a été à l'état",
    "    vrai (1). Si l'entrée a été vraie pendant au moins 1.000s la sortie",
    "    devient vraie (1).L'entrée n'a pas besoin d'être vraie pendant 1000 ms",
    "    consécutives. Si l'entrée est vraie pendant 0.6 seconde puis fausse",
    "    pendant 2.0 secondes et ensuite vraie pendant 0.4 seconde, la sortie",
    "    va devenir vraie. Après être passé à l'état vrai, la sortie reste",
    "    vraie quelque soit la commande de l'instruction. La temporisation",
    "    doit être remise à zéro par une instruction de RES (reset).",
    "",
    "    La variable `Tnom' compte depuis zéro en unités de temps de scan.",
    "    L'instruction Ton devient vraie en sortie quand la variable du",
    "    compteur est plus grande ou égale au delai fixé. Il est possible",
    "    de manipuler la variable du compteur en dehors, par exemple par une",
    "    instruction MOVE.",
    "",
    "",
    "> RES Remise à Zéro             Trto             Citems",
    "                           ----{RES}----     ----{RES}----",
    "",
    "    Cette instruction fait un remise à zéro d'une temporisation ou d'un",
    "    compteur. Les tempos TON et TOF sont automatiquement remisent à zéro",
    "    lorsque leurs entrées deviennent respectivement fausses ou vraies,",
    "    RES n'est pas donc pas nécessaire pour ces tempos. Les tempos RTO",
    "    et les compteurs décompteurs CTU / CTD ne sont pas remis à zéro",
    "    automatiquement, il faut donc utiliser cette instruction. Lorsque",
    "    l'entrée est vraie , le compteur ou la temporisation est remis à",
    "    zéro. Si l'entrée reste à zéro, aucune action n'est prise.",
    "    Cette instruction est placée le plus à droite dans une séquence.",
    "",
    "",
    "> FRONT MONTANT                    _",
    "                           --[OSR_/ ]--",
    "",
    "    La sortie de cette instruction est normallement fausse. Si",
    "    l'instruction d'entrée est vraie pendant ce scan et qu'elle était",
    "    fausse pendant le scan précédent alors la sortie devient vraie. Elle",
    "    génére une impulsion à chaque front montant du signal d'entrée. Cette",
    "    instruction est utile si vous voulez intercepter le front montant",
    "    du signal.",
    "",
    "",
    "> FRONT DESCENDANT               _",
    "                           --[OSF \\_]--",
    "",
    "    La sortie de cette instruction est normallement fausse. Si",
    "    l'instruction d'entrée est fausse (0) pendant ce scan et qu'elle",
    "    était vraie (1) pendant le scan précédent alors la sortie devient",
    "    vraie. Elle génére une impulsion à chaque front descendant du signal",
    "    d'entrée. Cette instruction est utile si vous voulez intercepter le",
    "    front descendant d'un signal.",
    "",
    "",
    "> COURT CIRCUIT (SHUNT), CIRCUIT OUVERT",
    "                           ----+----+----      ----+     +----",
    "",
    "    Une instruction shunt donne en sortie une condition qui est toujours ",
    "    égale à la condition d'entrée. Une instruction Circuit Ouvert donne ",
    "    toujours une valeur fausse en sortie.",
    "    Ces instructions sont en général utilisées en phase de test.",
    "",
    "",
    "> RELAIS DE CONTROLE MAITRE",
    "                           -{MASTER RLY}-",
    "",
    "    Par défaut, la condition d'entrée d'une ligne est toujours vraie. Si",
    "    une instruction Relais de contrôle maitre est exécutée avec une",
    "    valeur d'entrée fausse, alors toutes les lignes suivantes deviendront",
    "    fausses. Ceci va continuer jusqu'à la rencontre de la prochaine",
    "    instruction relais de contrôle maitre qui annule l'instruction de",
    "    départ. Ces instructions doivent toujours être utilisées par paires:",
    "    une pour commencer (qui peut être sous condition) qui commence la",
    "    partie déactivée et une pour la terminer.",
    "",
    "",
    "> MOUVOIR                   {destvar :=  }      {Tret :=     }",
    "                           -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "    Lorsque l'entrée de cette instruction est vraie, elle va mettre la",
    "    variable de destination à une valeur égale à la variable source ou à",
    "    la constante source. Quand l'entrée de cette instruction est fausse",
    "    rien ne se passe. Vous pouvez affecter n'importe quelle variable",
    "    à une instruction de déplacement, ceci inclu l'état de variables",
    "    compteurs ou temporisateurs qui se distinguent par l'entête T ou",
    "    C. Par exemple mettre 0 dans Tsauvegardé équivaut à faire une RES",
    "    de la temporisation.  Cette instruction doit être complétement à",
    "    droite dans une séquence.",
    "",
    "",
    "> OPERATIONS ARITHMETIQUES   {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                            {MUL  dest :=}       {DIV  dv :=  }",
    "                            -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "    Quand l'entrée de cette instruction est vraie, elle place en",
    "    destination la variable égale à l'expression calculée. Les opérandes",
    "    peuvent être des variables (en incluant les variables compteurs et",
    "    tempos) ou des constantes. Ces instructions utilisent des valeurs 16",
    "    bits signées. Il faut se souvenir que le résultat est évalué à chaque",
    "    cycle tant que la condition d'entrée est vraie. Si vous incrémentez",
    "    ou décrémentez une variable (si la variable de destination est",
    "    aussi une des opérandes), le résultat ne sera pas celui escompté,",
    "    il faut utiliser typiquement un front montant ou descendant de la",
    "    condition d'entrée qui ne sera évalué qu'une seule fois. La valeur",
    "    est tronquée à la valeur entière.  Cette instruction doit être",
    "    complétement à droite dans une séquence.",
    "",
    "",
    "> COMPARER              [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]       [-4 <   ]       [1 <=]",
    "                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-",
    "",
    "    Si l'entrée de cette instruction est fausse alors la sortie est",
    "    fausse.  Si l'entrée est vraie, alors la sortie sera vraie si et",
    "    uniquement si la condition de sortie est vraie. Cette instruction",
    "    est utilisée pour comparer (Egalité, plus grand que,plus grand ou",
    "    égal à, inégal, plus petit que, plus petit ou égal à) une variable à",
    "    une autre variable, ou pour comparer une variable avec une constante",
    "    16 bits signée.",
    "",
    "",
    "> COMPTEUR DECOMPTEUR          Cnom           Cnom",
    "                           --[CTU >=5]--  --[CTD >=5]--",
    "",
    "    Un compteur incrémente ( Compteur CTU, count up) ou décrémente",
    "    (Décompteur CTD, count down) une variable à chaque front montant de",
    "    la ligne en condition d'entrée (CAD quand la signal passe de l'état",
    "    0 à l'état 1. La condition de sortie du compteur est vraie si la",
    "    variable du compteur est égale ou plus grande que 5 (dans l'exemple),",
    "    et faux sinon. La condition de sortie de la ligne peut être vraie,",
    "    même si la condition d'entrée est fausse, cela dépend uniquement de la",
    "    valeur de la variable du compteur. Vous pouvez avoir un compteur ou",
    "    un décompteur avec le même nom, qui vont incréménter ou decrémenter",
    "    une variable.  L'instruction Remise à Zéro permet de resetter un",
    "    compteur (remettre à zéro), il est possible de modifier par des",
    "    opérations les variables des compteurs décompteurs.",
    "",
    "",
    "> COMPTEUR CYCLIQUE             Cnom",
    "                           --{CTC 0:7}--",
    "",
    "    Un compteur cyclique fonctionne comme un compteur normal",
    "    CTU, exception faite, lorsque le compteur arrive à sa",
    "    limite supérieure, la variable du compteur revient à 0. dans",
    "    l'exemple la valeur du compteur évolue de la façon suivante :",
    "    0,1,2,4,5,6,7,0,1,2,3,4,5,6,7,0,1,3,4,5,etc. Ceci est très pratique",
    "    en conbinaison avec des intructions conditionnelles sur la variable",
    "    Cnom. On peut utiliser ceci comme un séquenceur, l'horloge du compteur",
    "    CTC est validée par la condition d'entrée associée à une instruction",
    "    de front montant.",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "    ",
    "",
    "> REGISTRE A DECALAGE       {SHIFT REG   }",
    "                           -{ reg0..3    }-",
    "",
    "    Un registre à décalage est associé avec un jeu de variables. Le",
    "    registre à décalage de l'exemple donné est associé avec les",
    "    variables`reg0', `reg1', `reg2', and `reg3'. L'entrée du registre à",
    "    décalage est `reg0'. A chaque front montant de la condition d'entrée",
    "    de la ligne, le registre à décalage va décaler d'une position à",
    "    droite. Ce qui donne `reg3 := reg2', `reg2 := reg1'. et `reg1 :=",
    "    reg0'.`reg0' est à gauche sans changement. Un registre à décalage",
    "    de plusieurs éléments peut consommer beaucoup de place en mémoire.",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "",
    "",
    "> TABLEAU INDEXE            {dest :=     }",
    "                           -{ LUT[i]     }-",
    "",
    "    Un tableau indexé et un groupe ordonné de n valeurs Quand la condition",
    "    d'entrée est vraie, la variable entière `dest' est mise à la valeur",
    "    correspondand à l'index i du tableau. L'index est compris entre 0 et",
    "    (n-1). Le comportement de cette instruction est indéfini si l'index",
    "    est en dehors du tableau",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "",
    "",
    "> TABLEAU ELEMENTS LINEAIRES {yvar :=     }",
    "                            -{ PWL[xvar]  }-",
    "",
    "    C'est une bonne méthode pour évaluer de façon approximative une",
    "    fonction compliquée ou une courbe. Très pratique par exemple pour",
    "    appliquer une courbe de calibration pour linéariser tension de sortie",
    "    d'un capteur dans une unité convenable.",
    "",
    "    Supposez que vous essayez de faire une fonction pour convertir une",
    "    variable d'entrée entière, x, en une variable de sortie entière, y,",
    "    vous connaissez la fonction en différents points, par exemple vous",
    "    connaissez :",
    "",
    "        f(0)   = 2",
    "        f(5)   = 10",
    "        f(10)  = 50",
    "        f(100) = 100",
    "",
    "    Ceci donne les points",
    "",
    "        (x0, y0)   = (  0,   2)",
    "        (x1, y1)   = (  5,  10)",
    "        (x2, y2)   = ( 10,  50)",
    "        (x3, y3)   = (100, 100)",
    "",
    "    liés à cette courbe. Vous pouvez entrer ces 4 points dans un",
    "    tableau associé à l'instruction tableau d'éléments linéaires. Cette",
    "    instruction regarde la valeur de xvar et fixe la valeur de yvar",
    "    correspondante. Par exemple si vous mettez xvar = 10 , l'instruction",
    "    validera yvar = 50.",
    "",
    "    Si vous mettez une instruction avec une valeur xvar entre deux valeurs",
    "    de x du tableau (et par conséquence aussi de yvar). Une moyenne",
    "    proportionnelle entre les deux valeurs , précédente et suivante de",
    "    xvar et de la valeur liée yvar, est effectuée. Par exemple xvar =",
    "    55 donne en sortie yvar = 75 Les deux points xvar (10.50) et yvar",
    "    (50,75) , 55 est la moyenne entre 10 et 100 et 75 est la moyenne",
    "    entre 50 et 100, donc (55,75) sont liés ensemble par une ligne de",
    "    connection qui connecte ces deux points.",
    "",
    "    Ces points doivent être spécifiés dans l'ordre ascendant des",
    "    coordonnées x.  Il peut être impossible de faire certaines opérations",
    "    mathématiques nécessaires pour certains tableaux, utilisant des",
    "    entiers 16 bits. Dans ce POPTools va provoquer une alarme. Ce tableau",
    "    va provoquer une erreur :",
    "",
    "        (x0, y0)    = (  0,   0)",
    "        (x1, y1)    = (300, 300)",
    "",
    "    Vous pouvez supprimer ces erreurs en diminuant l'écart entre les",
    "    points du tableau, par exemple ce tableau est équivalent à celui ci",
    "    dessus , mais ne provoque pas d'erreur:",
    "",
    "        (x0, y0)    = (  0,   0)",
    "        (x1, y1)    = (150, 150)",
    "        (x2, y2)    = (300, 300)",
    "",
    "    Il n'est pratiquement jamais nécessaire d'utiliser plus de 5 ou",
    "    6 points.  Ajouter des points augmente la taille du code et diminue",
    "    sa vitesse d'exécution. Le comportement, si vous passez une valeur",
    "    à xvar plus grande que la plus grande valeur du tableau , ou plus",
    "    petit que la plus petite valeur, est indéfini.",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "",
    "",
    "> LECTURE CONVERTISSEUR A/D    Anom",
    "                           --{READ ADC}--",
    "",
    "    POPTools peut générer du code pour utiliser les convertisseurs A/D",
    "    contenus dans certains microcontroleurs. Si la condition d'entrée",
    "    de l'instruction est vraie, alors une acquisition du convertisseur",
    "    A/D est éffectuée et stockée dans la variable Anom. Cette variable",
    "    peut être par la suite traitée comme les autres variables par les",
    "    différentes opérations arithmétiques ou autres. Vous devez affecter",
    "    une broche du micro à la variable Anom de la même façon que pour",
    "    les entrées et sorties digitales par un double clic dans la list",
    "    affichée au bas de l'écran. Si la condition d'entrée de la séquence",
    "    est fausse la variable Anom reste inchangée.",
    "",
    "    Pour tous les circuits supportés actuellement, 0 volt en entrée",
    "    correspond à une lecture ADC de 0, et une valeur égale à VDD (la",
    "    tension d'alimentation ) correspond à une lecture ADC de 1023. Si",
    "    vous utilisez un circuit AVR, vous devez connecter Aref à VDD.",
    "",
    "    Vous pouvez utiliser les opérations arithmétiques pour mettre à ",
    "    l'échelle les lectures effectuées dans l'unité qui vous est la plus ",
    "    appropriée. Mais souvenez vous que tous les calculs sont faits en ",
    "    utilisant les entiers.",
    "",
    "    En général, toutes les broches ne sont pas utilisables pour les ",
    "    lecture de convertisseur A/D. Le logiciel ne vous permet pas ",
    "    d'affecter une broche non A/D pour une entrée convertisseur.",
    "    Cette instruction doit être complétement à droite dans une séquence.",
    "",
    "",
    "> FIXER RAPPORT CYCLE PWM    duty_cycle",
    "                           -{PWM 32.8 kHz}-",
    "",
    "    POPTools peut générer du code pour utiliser les périphériques PWM",
    "    contenus dans certains microcontroleurs. Si la condition d'entrée",
    "    de cette instruction est vraie, le rapport de cycle du périphérique",
    "    PWM va être fixé à la valeur de la variable Rapport de cycle PWM.",
    "    Le rapport de cycle est un nombre compris entre 0 (toujours au",
    "    niveau bas) et 100 (toujours au niveau haut). Si vous connaissez la",
    "    manière dont les périphériques fonctionnent vous noterez que POPTools",
    "    met automatiquement à l'échelle la variable du rapport de cycle en",
    "    pourcentage de la période d'horloge PWM.",
    "",
    "    Vous pouvez spécifier la fréquence de sortie PWM, en Hertz. Le",
    "    fréquence que vous spécifiez peut ne pas être exactement accomplie, en",
    "    fonction des divisions de la fréquence d'horloge du microcontroleur,",
    "    POPTools va choisir une fréquence approchée. Si l'erreur est trop",
    "    importante, il vous avertit.Les vitesses rapides sont au détriment",
    "    de la résolution. Cette instruction doit être complétement à droite",
    "    dans une séquence.",
    "",
    "    Le runtime du language à contacts consomme un timers (du micro) pour",
    "    le temps de cycle, ce qui fait que le PWM est uniquement possible",
    "    avec des microcontroleurs ayant au moins deux timers utilisables.",
    "    PWM utilise CCP2 (pas CCP1) sur les PIC16F et OC2(pas OC1) sur les",
    "    Atmel AVR.",
    "",
    "> METTRE PERSISTANT          saved_var",
    "                           --{PERSIST}--",
    "",
    "    Quand la condition d'entrée de cette instruction est vraie, la",
    "    variable entière spécifiée va être automatiquement sauvegardée en",
    "    EEPROM, ce qui fait que cette valeur persiste même après une coupure",
    "    de l'alimentation du micro. Il n'y a pas à spécifier ou elle doit",
    "    être sauvegardée en EEPROM, ceci est fait automatiquement, jusqu'a",
    "    ce quelle change à nouveau.  La variable est automatiquement chargée",
    "    à partir de l'EEPROM suite à un reset à la mise sous tension.",
    "",
    "    Si une variables, mise persistante, change fréquemment, l'EEPROM de",
    "    votre micro peut être détruite très rapidement, Le nombre de cycles",
    "    d'écriture dans l'EEPROM est limité à environ 100 000 cycles Quand",
    "    la condition est fausse, rien n'apparait. Cette instruction doit",
    "    être complétement à droite dans une séquence.",
    "",
    "",
    "> RECEPTION UART (SERIE)         var",
    "                           --{UART RECV}--",
    "",
    "    POPTools peut générer du code pour utiliser l'UART, existant dans",
    "    certains microcontroleurs. Sur les AVR, avec de multiples UART,",
    "    uniquement l'UART1 est utilisable (pas l'UART0). Configurer la",
    "    vitesse en utilisant -> Paramètres -> Paramètres MCU. Toutes les",
    "    vitesses de liaison ne sont pas utilisables avec tous les quartz de",
    "    toutyes les fréquences. POPTools vous avertit dans ce cas.",
    "",
    "    Si la condition d'entrée de cette instruction est fausse, rien ne se",
    "    passe. Si la condition d'entrée est vraie, elle essaie de recevoir",
    "    un caractère en provenance de l'UART. Si aucun caractère n'est lu",
    "    alors la condition de sortie devient fausse. Si un caractère est",
    "    lu la valeur ASCII est stockée dans 'var' et la condition de sortie",
    "    est vraie pour un seul cycle API.",
    "",
    "",
    "> EMMISION UART (SERIE)          var",
    "                           --{UART SEND}--",
    "",
    "    POPTools peut générer du code pour utiliser l'UART, existant dans ",
    "    certains microcontroleurs. Sur les AVR, avec de multiples UART, ",
    "    uniquement l'UART1 est utilisable (pas l'UART0). Configurer la ",
    "    vitesse en utilisant -> Paramètres -> Paramètres MCU. Toutes les ",
    "    vitesses de liaison ne sont pas utilisables avec tous les quartz ",
    "    de toutyes les fréquences. POPTools vous avertit dans ce cas.",
    "",
    "    Si la condition d'entrée de cette instruction est fausse, rien ne",
    "    se passe. Si la condition d'entrée est vraie alors cette instruction",
    "    écrit un seul caractère vers l'UART. La valeur ASCII du caractère à",
    "    transmettre doit avoir été stocké dans 'var' par avance. La condition",
    "    de sortie de la séquence est vraie, si l'UART est occupée (en cours",
    "    de transmission d'un caractère), et fausse sinon.",
    "",
    "",
    NULL
};
#endif

#ifdef LDLANG_TR
char *HelpTextTr[] = {
    "",
    "KULLANIM KÝTAPÇIÐI",
    "==================",
    "POPTools desteklenen MicroChip PIC16 ve Atmel AVR mikrokontrolcüler için ",
    "gerekli kodu üretir. Bu iþ için kullanýlabilecek deðiþik programlar vardýr.",
    "Örneðin BASIC, C, assembler gibi. Bu programlar kendi dillerinde yazýlmýþ",
    "programlarý iþlemcilerde çalýþabilecek dosyalar haline getirirler.",
    "",
    "PLC'de kullanýlan dillerden biri  ladder diyagramýdýr. Aþaðýda POPTools ile",
    "yazýlmýþ basit bir program görülmektedir.",
    "",
    "   ||                                                                    ||",
    "   ||    Xbutton1           Tdon           Rchatter           Yred       ||",
    " 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||",
    "   ||                                 |                                  ||",
    "   ||    Xbutton2           Tdof      |                                  ||",
    "   ||-------]/[---------[TOF 2.000 s]-+                                  ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||    Rchatter            Ton             Tnew           Rchatter     ||",
    " 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||------[END]---------------------------------------------------------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "",
    "(TON=turn-on gecikme; TOF-turn-off gecikme. --] [-- giriþler, diðer bir ",
    "deyiþle kontaklardýr. --( )-- ise çýkýþlardýr. Bunlar bir rölenin bobini ",
    "gibi davranýrlar. Ladder diyagramý ile ilgili bol miktarda kaynak internet",
    "üzerinde bulunmaktadýr. Burada POPTools'ya has özelliklerden bahsedeceðiz.",
    "",
    "POPTools ladder diyagramýný PIC16 veya AVR koduna çevirir. Aþaðýda desteklenen",
    "iþlemcilerin listesi bulunmaktadýr:",
    "    * PIC16F877",
    "    * PIC16F628",
    "    * PIC16F876 (denenmedi)",
    "    * PIC16F88 (denenmedi)",
    "    * PIC16F819 (denenmedi)",
    "    * PIC16F887 (denenmedi)",
    "    * PIC16F886 (denenmedi)",
    "    * ATmega128",
    "    * ATmega64",
    "    * ATmega162 (denenmedi)",
    "    * ATmega32 (denenmedi)",
    "    * ATmega16 (denenmedi)",
    "    * ATmega8 (denenmedi)",
    "",
    "Aslýnda daha fazla PIC16 ve AVR iþlemci desteklenebilir. Ancak test ettiklerim",
    "ve desteklediðini düþündüklerimi yazdým. Örneðin PIC16F648 ile PIC16F628 ",
    "arasýnda fazla bir fark bulunmamaktadýr. Eðer bir iþlemcinin desteklenmesini",
    "istiyorsanýz ve bana bildirirseniz ilgilenirim.",
    "",
    "POPTools ile ladder diyagramýný çizebilir, devrenizi denemek için gerçek zamanlý ",
    "simülasyon yapabilirsiniz. Programýnýzýn çalýþtýðýndan eminseniz programdaki ",
    "giriþ ve çýkýþlara mikrokontrolörün bacaklarýný atarsýnýz. Ýþlemci bacaklarý ",
    "belli olduktan sonra programýnýzý derleyebilirsiniz. Derleme sonucunda oluþan",
    "dosya .hex dosyasýdýr. Bu dosyayý PIC/AVR programlayýcý ile iþlemcinize kaydedersiniz.",
    "PIC/AVR ile uðraþanlar konuya yabancý deðildir.",
    "",
    "",
    "POPTools ticari PLC programlarý gibi tasarlanmýþtýr. Bazý eksiklikler vardýr. ",
    "Kitapçýðý dikkatlice okumanýzý tavsiye ederim. Kullaným esnasýnda PLC ve ",
    "PIC/AVR hakkýnda temel bilgilere sahip olduðunuz düþünülmüþtür.",
    "",
    "DÝÐER AMAÇLAR",
    "==================",
    "",
    "ANSI C kodunu oluþturmak mümkündür. C derleyicisi olan herhangi bir",
    "iþlemci için bu özellikten faydalanabilirsiniz. Ancak çalýþtýrmak için ",
    "gerekli dosyalarý siz saðlamalýsýnýz. Yani, POPTools sadece PlcCycle()",
    "isimli fonksiyonu üretir. Her döngüde PlcCycle fonksiyonunu çaðýrmak, ve",
    "PlcCycle() fonksiyonunun çaðýrdýðý dijital giriþi yazma/okuma vs gibi",
    "G/Ç fonksiyonlarý sizin yapmanýz gereken iþlemlerdir.",
    "Oluþturulan kodu incelerseniz faydalý olur.",
    "",
    "KOMUT SATIRI SEÇENEKLERÝ",
    "========================",
    "",
    "Normal þartlarda POPTools.exe komut satýrýndan seçenek almadan çalýþýr.",
    "POPTools'ya komut satýrýndan dosya ismi verebilirsiniz. Örneðin;komut",
    "satýrýndan 'POPTools.exe asd.ld' yazarsanýz bu dosya açýlmaya çalýþýrlýr.",
    "Dosya varsa açýlýr. Yoksa hata mesajý alýrsýnýz. Ýsterseniz .ld uzantýsýný",
    "POPTools.exe ile iliþkilendirirseniz .ld uzantýlý bir dosyayý çift týklattýðýnýzda",
    "bu dosya otomatik olarak açýlýr. Bkz. Klasör Seçenekleri (Windows).",
    "",
    "`POPTools.exe /c src.ld dest.hex', þeklinde kullanýlýrsa  src.ld derlenir",
    "ve hazýrlanan derleme dest.hex dosyasýna kaydedilir. Ýþlem bitince POPTools kapanýr.",
    "Oluþabilecek tüm mesajlar konsoldan görünür.",
    "",
    "TEMEL BÝLGÝLER",
    "==============",
    "",
    "POPTools açýldýðýnda boþ bir program ile baþlar. Varolan bir dosya ile baþlatýrsanýz",
    "bu program açýlýr. POPTools kendi dosya biçimini kullandýðýndan diðer dosya",
    "biçimlerinden dosyalarý açamazsýnýz.",
    "",
    "Boþ bir dosya ile baþlarsanýz ekranda bir tane boþ satýr görürsünüz. Bu satýra",
    "komutlarý ekleyebilir, satýr sayýsýný artýrabilirsiniz. Satýrlara Rung denilir.",
    "Örneðin; Komutlar->Kontak Ekle diyerek bir kontak ekleyebilirsiniz. Bu kontaða",
    "'Xnew' ismi verilir. 'X' bu kontaðýn iþlemcinin bacaðýna denk geldiðini gösterir.",
    "Bu kontaða derlemeden önce isim vermeli ve mikrokontrolörün bir bacaðý ile",
    "eþleþtirmelisiniz. Eþleþtirme iþlemi içinde önce iþlemciyi seçmelisiniz.",
    "Elemanlarýn ilk harfi o elemanýn ne olduðu ile ilgilidir. Örnekler:",
    "",
    "    * Xname -- mikrokontrolördeki bir giriþ bacaðý",
    "    * Yname -- mikrokontrolördeki bir çýkýþ bacaðý",
    "    * Rname -- `dahili röle': hafýzada bir bit.",
    "    * Tname -- zamanlayýcý; turn-on, turn-off yada retentive ",
    "    * Cname -- sayýcý, yukarý yada aþaðý sayýcý",
    "    * Aname -- A/D çeviriciden okunan bir tamsayý deðer",
    "    * name  -- genel deðiþken (tamsayý)",
    "",
    "Ýstediðiniz ismi seçebilirsiniz. Seçilen bir isim nerede kullanýlýrsa",
    "kullanýlsýn ayný yere denk gelir. Örnekler; bir satýrda Xasd kullandýðýnýzda",
    "bir baþka satýrda Xasd kullanýrsanýz ayný deðere sahiptirler. ",
    "Bazen bu mecburi olarak kullanýlmaktadýr. Ancak bazý durumlarda hatalý olabilir.",
    "Mesela bir (TON) Turn-On Gecikmeye Tgec ismini verdikten sonra bir (TOF)",
    "Turn_Off gecikme devresine de Tgec ismini verirseniz hata yapmýþ olursunuz.",
    "Dikkat ederseniz yaptýðýnýz bir mantýk hatasýdýr. Her gecikme devresi kendi",
    "hafýzasýna sahip olmalýdýr. Ama Tgec (TON) turn-on gecikme  devresini sýfýrlamak",
    "için kullanýlan RES komutunda Tgec ismini kullanmak gerekmektedir.",
    "",
    "Deðiþken isimleri harfleri, sayýlarý, alt çizgileri ihtiva edebilir.",
    "(_). Deðiþken isimleri sayý ile baþlamamalýdýr. Deðiþken isimleri büyük-küçük harf duyarlýdýr.",
    "Örneðin; TGec ve Tgec ayný zamanlayýcýlar deðildir.",
    "",
    "",
    "Genel deðiþkenlerle ilgili komutlar (MOV, ADD, EQU vs) herhangi bir",
    "isimdeki deðiþkenlerle çalýþýr. Bunun anlamý bu komutlar zamanlayýcýlar",
    "ve sayýcýlarla çalýþýr. Zaman zaman bu faydalý olabilir. Örneðin; bir ",
    "zamanlayýcýnýn deðeri ile ilgili bir karþýlaþtýrma yapabilirsiniz.",
    "",
    "Deðiþkenler hr zaman için 16 bit tamsayýdýr. -32768 ile 32767 arasýnda",
    "bir deðere sahip olabilirler. Her zaman için iþaretlidir. (+ ve - deðere",
    "sahip olabilirler) Onluk sayý sisteminde sayý kullanabilirsiniz. Týrnak",
    "arasýna koyarak ('A', 'z' gibi) ASCII karakterler kullanabilirsiniz.",
    "",
    "Ekranýn alt tarafýndaki kýsýmda kullanýlan tüm elemanlarýn bir listesi görünür.",
    "Bu liste program  tarafýndan otomatik olarak oluþturulur ve kendiliðinden",
    "güncelleþtirilir. Sadece 'Xname', 'Yname', 'Aname' elemanlarý için",
    "mikrokontrolörün bacak numaralarý belirtilmelidir. Önce Ayarlar->Ýþlemci Seçimi",
    "menüsünden iþlemciyi seçiniz. Daha sonra G/Ç uçlarýný çift týklatarak açýlan",
    "pencereden seçiminizi yapýnýz.",
    "",
    "Komut ekleyerek veya çýkararak programýnýzý deðiþtirebilirsiniz. Programdaki",
    "kursör eleman eklenecek yeri veya hakkýnda iþlem yapýlacak elemaný göstermek",
    "amacýyla yanýp söner. Elemanlar arasýnda <Tab> tuþu ile gezinebilirsiniz. Yada",
    "elemaný fare ile týklatarak iþlem yapýlacak elemaný seçebilirsiniz. Kursör elemanýn",
    "solunda, saðýnda, altýnda ve üstünde olabilir. Solunda ve saðýnda olduðunda",
    "ekleme yaptýðýnýzda eklenen eleman o tarafa eklenir. Üstünde ve altýnda iken",
    "eleman eklerseniz eklenen eleman seçili elemana paralel olarak eklenir.",
    "Bazý iþlemleri yapamazsýnýz. Örneðin bir bobinin saðýna eleman ekleyemezsiniz.",
    "POPTools buna izin vermeyecektir.",
    "",
    "Program boþ bir satýrla baþlar. Kendiniz alta ve üste satýr ekleyerek dilediðiniz",
    "gibi diyagramýnýzý oluþturabilirsiniz. Yukarýda bahsedildiði gibi alt devreler",
    "oluþturabilirsiniz.",
    "",
    "Programýnýz yazdýðýnýzda simülasyon yapabilir, .hex dosyasýný oluþturabilirsiniz.",
    "",
    "SÝMÜLASYON",
    "==========",
    "",
    "Simülasyon moduna geçmek için Simülasyon->Simülasyon modu menüsünü týklatabilir,",
    "yada <Ctrl+M> tuþ kombinasyonuna basabilirsiniz. Simülasyon modunda program",
    "farklý bir görüntü alýr. Kursör görünmez olur. Enerji alan yerler ve elemanlar",
    "parlak kýrmýzý, enerji almayan yerler ve elemanlar gri görünür. Boþluk tuþuna",
    "basarak bir çevrim ilerleyebilir yada menüden Simülasyon->Gerçek Zamanlý Simülasyonu Baþlat",
    "diyerek (veya <Ctrl+R>) devamlý bir çevrim baþlatabilirsiniz. Ladder diyagramýnýn",
    "çalýþmasýna göre gerçek zamanlý olarak elemanlar ve yollar program tarafýndan deðiþtirilir.",
    "",
    "Giriþ elemanlarýnýn durumunu çift týklatarak deðiþtirebilirsiniz. Mesela, 'Xname'",
    "kontaðýný çift týklatýranýz açýktan kapalýya veya kapalýdan açýða geçiþ yapar.",
    "",
    "DERLEME",
    "=======",
    "",
    "Ladder diyagramýnýn yapýlmasýndaki amaç iþlemciye yüklenecek .hex dosyasýnýn",
    "oluþturulmasýdýr. Buna 'derleme' denir. Derlemeden önce þu aþamalar tamamlanmalýdýr:",
    " 1- Ýþlemci seçilmelidir. Ayarlar->Ýþlemci Seçimi menüsünden yapýlýr.",
    " 2- G/Ç uçlarýnýn mikrokontrolördeki hangi bacaklara baðlanacaðý seçilmelidir.",
    "    Elemanýn üzerine çift týklanýr ve çýkan listeden seçim yapýlýr.",
    " 3- Çevrim süresi tanýmlanmalýdýr. Ayarlar->Ýþlemci Ayarlarý menüsünden yapýlýr.",
    "	Bu süre iþlemcinin çalýþtýðý frekansa baðlýdýr. Çoðu uygulamalar için 10ms",
    "	uygun bir seçimdir. Ayný yerden kristal frekansýný ayarlamayý unutmayýnýz.",
    "",
    "Artýk kodu üretebilirsiniz. Derle->Derle yada Derle->Farklý Derle seçeneklerinden",
    "birini kullanacaksýnýz. Aradaki fark Kaydet ve Farklý Kaydet ile aynýdýr. Sonuçta",
    "Intel IHEX dosyanýz programýnýzda hata yoksa üretilecektir. Programýnýzda hata varsa",
    "uyarý alýrsýnýz.",
    "",
    "Progamlayýcýnýz ile bu dosyayý iþlemcinize yüklemelisiniz. Buradaki en önemli nokta",
    "iþlemcinin konfigürasyon bitlerinin ayarlanmasýdýr. PIC16 iþlemciler için gerekli ",
    "ayar bilgileri hex dosyasýna kaydedildiðinden programlayýcýnýz bu ayarlarý algýlayacaktýr.",
    "Ancak AVR iþlemciler için gerekli ayarlarý siz yapmalýsýnýz.",
    "",
    "KOMUTLAR ve ELEMANLAR",
    "=====================",
    "",
    "> KONTAK, NORMALDE AÇIK         Xname           Rname          Yname",
    "                             ----] [----     ----] [----    ----] [----",
    "",
    "    Normalde açýk bir anahtar gibi davranýr. Komutu kontrol eden sinyal 0 ise ",
    "	çýkýþýndaki sinyalde 0 olur. Eðer kontrol eden sinyal 1 olursa çýkýþý da 1",
    "	olur ve çýkýþa baðlý bobin aktif olur. Bu kontak iþlemci bacaðýndan alýnan",
    "	bir giriþ, çýkýþ bacaðý yada dahili bir röle olabilir.",
    "",
    "",
    "> KONTAK, NORMALDE KAPALI       Xname           Rname          Yname",
    "                             ----]/[----     ----]/[----    ----]/[----",
    "",
    "    Normalde kapalý bir anahtar gibi davranýr. Komutun kontrol eden sinyal 0 ise",
    "	çýkýþý 1 olur. Eðer kontrol eden sinyal 1 olursa çýkýþý 0 olur ve çýkýþa",
    "	baðlý elemanlar pasif olur. Normalde çýkýþa gerilim verilir, ancak bu kontaðý ",
    "	kontrol eden sinyal 1 olursa kontaðýn çýkýþýnda gerilim olmaz. Bu kontak ",
    "	iþlemci bacaðýndan alýnan bir giriþ, çýkýþ bacaðý yada dahili bir röle olabilir",
    "",
    "",
    "> BOBÝN, NORMAL                 Rname           Yname",
    "                             ----( )----     ----( )----",
    "",
    "    Elemana giren sinyal 0 ise dahili röle yada çýkýþ bacaðý 0 yapýlýr.",
    "	Elemana giren sinyal 1 ise dahili röle yada çýkýþ bacaðý 1 yapýlýr.",
    "	Bobine	giriþ deðiþkeni atamak mantýksýzdýr. Bu eleman bir satýrda",
    "	saðdaki en son eleman olmalýdýr.",
    "",
    "",
    "> BOBÝN, TERSLENMÝÞ             Rname           Yname",
    "                             ----(/)----     ----(/)----",
    "",
    "    Elemana giren sinyal 0 ise dahili röle yada çýkýþ bacaðý 1 yapýlýr.",
    "	Elemana giren sinyal 1 ise dahili röle yada çýkýþ bacaðý 0 yapýlýr.",
    "	Bobine	giriþ deðiþkeni atamak mantýksýzdýr. Bu eleman bir satýrda",
    "	saðdaki en son eleman olmalýdýr. Normal bobinin tersi çalýþýr.",
    "	",
    "",
    "> BOBÝN, SET                   Rname           Yname",
    "                             ----(S)----     ----(S)----",
    "",
    "   	Elemana giren sinyal 1 ise dahili röle yada çýkýþ bacaðý 1 yapýlýr.",
    "	Diðer durumlarda bu bobinin durumunda bir deðiþiklik olmaz. Bu komut",
    "	bobinin durumunu sadece 0'dan 1'e çevirir. Bu nedenle çoðunlukla",
    "	BOBÝN-RESET ile beraber çalýþýr. Bu eleman bir satýrda saðdaki en",
    "	son eleman olmalýdýr.",
    "",
    "",
    "> BOBÝN, RESET                 Rname           Yname",
    "                             ----(R)----     ----(R)----",
    "",
    "   	Elemana giren sinyal 1 ise dahili röle yada çýkýþ bacaðý 0 yapýlýr.",
    "	Diðer durumlarda bu bobinin durumunda bir deðiþiklik olmaz. Bu komut",
    "	bobinin durumunu sadece 1'dEn 0'a çevirir. Bu nedenle çoðunlukla",
    "	BOBÝN-SET ile beraber çalýþýr. Bu eleman bir satýrda saðdaki en",
    "	son eleman olmalýdýr.",
    "",
    "",
    "> TURN-ON GECÝKME               Tdon ",
    "                           -[TON 1.000 s]-",
    "",
    "    Bir zamanlayýcýdýr. Giriþindeki sinyal 0'dan 1'e geçerse ayarlanan",
    "	süre kadar sürede çýkýþ 0 olarak kalýr, süre bitince çýkýþý 1 olur. ",
    "    Giriþindeki sinyal 1'den 0'a geçerse çýkýþ hemen 0 olur.",
    "	Giriþi 0 olduðu zaman zamanlayýcý sýfýrlanýr. Ayrýca; ayarlanan süre",
    "	boyunca giriþ 1 olarak kalmalýdýr.",
    "",
    "    Zamanlayýcý 0'dan baþlayarak her çevrim süresinde 1 artarak sayar.",
    "	Sayý ayarlanan süreye eþit yada büyükse çýkýþ 1 olur. Zamanlayýcý",
    "	deðiþkeni üzerinde iþlem yapmak mümkündür. (Örneðin MOV komutu ile)",
    "",
    "",
    "> TURN-OFF GECÝKME               Tdoff ",
    "                           -[TOF 1.000 s]-",
    "",
    "    Bir zamanlayýcýdýr. Giriþindeki sinyal 1'den 0'a geçerse ayarlanan",
    "	süre kadar sürede çýkýþ 1 olarak kalýr, süre bitince çýkýþý 0 olur. ",
    "    Giriþindeki sinyal 0'dan 1'e geçerse çýkýþ hemen 1 olur.",
    "	Giriþi 0'dan 1'e geçtiðinde zamanlayýcý sýfýrlanýr. Ayrýca; ayarlanan",
    "	süre boyunca giriþ 0 olarak kalmalýdýr.",
    "",
    "    Zamanlayýcý 0'dan baþlayarak her çevrim süresinde 1 artarak sayar.",
    "	Sayý ayarlanan süreye eþit yada büyükse çýkýþ 1 olur. Zamanlayýcý",
    "	deðiþkeni üzerinde iþlem yapmak mümkündür. (Örneðin MOV komutu ile)",
    "",
    "",
    "> SÜRE SAYAN TURN-ON GECÝKME        Trto  ",
    "                               -[RTO 1.000 s]-",
    "",
    "	Bu zamanlayýcý giriþindeki sinyalin ne kadar süre ile 1 olduðunu",
    "	ölçer. Ayaralanan süre boyunca giriþ 1 ise çýkýþý 1 olur. Aksi halde",
    "	çýkýþý 0 olur. Ayarlanan süre devamlý olmasý gerekmez. Örneðin; süre ",
    "	1 saniyeye ayarlanmýþsa ve giriþ önce 0.6 sn 1 olmuþsa, sonra 2.0 sn",
    "	boyunca 0 olmuþsa daha sonra 0.4 sn boyunca giriþ tekrar 1 olursa",
    "	0.6 + 0.4 = 1sn olduðundan çýkýþ 1 olur. Çýkýþ 1 olduktan sonra",
    "	giriþ 0 olsa dahi çýkýþ 0'a dönmez. Bu nedenle zamanlayýcý RES reset",
    "	komutu ile resetlenmelidir.",
    "",
    "    Zamanlayýcý 0'dan baþlayarak her çevrim süresinde 1 artarak sayar.",
    "	Sayý ayarlanan süreye eþit yada büyükse çýkýþ 1 olur. Zamanlayýcý",
    "	deðiþkeni üzerinde iþlem yapmak mümkündür. (Örneðin MOV komutu ile)",
    "",
    "",
    "> RESET (SAYICI SIFIRLAMASI)     Trto             Citems",
    "                             ----{RES}----     ----{RES}----",
    "",
    "    Bu komut bir zamanlayýcý veya sayýcýyý sýfýrlar. TON ve TOF zamanlayýcý",
    "	komutlarý kendiliðinden sýfýrlandýðýndan bu komuta ihtiyaç duymazlar.",
    "	RTO zamanlayýcýsý ve CTU/CTD sayýcýlarý kendiliðinden sýfýrlanmadýðýndan",
    "	sýfýrlanmalarý için kullanýcý tarafýndan bu komutile sýfýrlanmasý",
    "	gerekir. Bu komutun giriþi 1 olduðunda sayýcý/zamanlayýcý sýfýrlanýr.",
    "	Bu komut bir satýrýn saðýndaki son komut olmalýdýr.",
    "",
    "",
    "> YÜKSELEN KENAR                 _",
    "                           --[OSR_/ ]--",
    "",
    "    Bu komutun çýkýþý normalde 0'dýr. Bu komutun çýkýþýnýn 1 olabilmesi",
    "	için bir önceki çevrimde giriþinin 0 þimdiki çevrimde giriþinin 1 ",
    "	olmasý gerekir. Komutun çýkýþý bir çevrimlik bir pals üretir.",
    "	Bu komut bir sinyalin yükselen kenarýnda bir tetikleme gereken",
    "	uygulamalarda faydalýdýr.",
    "	",
    "",
    "> DÜÞEN KENAR                    _",
    "                           --[OSF \\_]--",
    "",
    "    Bu komutun çýkýþý normalde 0'dýr. Bu komutun çýkýþýnýn 1 olabilmesi",
    "	için bir önceki çevrimde giriþinin 1 þimdiki çevrimde giriþinin 0 ",
    "	olmasý gerekir. Komutun çýkýþý bir çevrimlik bir pals üretir.",
    "	Bu komut bir sinyalin düþen kenarýnda bir tetikleme gereken",
    "	uygulamalarda faydalýdýr.",
    "",
    "",
    "> KISA DEVRE, AÇIK DEVRE",
    "                           ----+----+----      ----+     +----",
    "",
    "    Kýsa devrenin çýkýþý her zaman giriþinin aynýsýdýr.",
    "	Açýk devrenin çýkýþý her zaman 0'dýr. Bildiðimiz açýk/kýsa devrenin",
    "	aynýsýdýr. Genellikle hata aramada kullanýlýrlar.",
    "",
    "> ANA KONTROL RÖLESÝ",
    "                           -{MASTER RLY}-",
    "",
    "    Normalde her satýrýn ilk giriþi 1'dir. Birden fazla satýrýn tek bir þart ile ",
    "	kontrol edilmesi gerektiðinde paralel baðlantý yapmak gerekir. Bu ise zordur.",
    "	Bu iþlemi kolayca yapabilmek için ana kontrol rölesini kullanabiliriz.",
    "	Ana kontrol rölesi eklendiðinde kendisinden sonraki satýrlar bu röleye baðlý",
    "	hale gelir. Böylece; birden fazla satýr tek bir þart ile kontrolü saðlanýr.",
    "	Bir ana kontrol rölesi kendisinden sonra gelen ikinci bir ana kontrol",
    "	rölesine kadar devam eder. Diðer bir deyiþle birinci ana kontrol rölesi",
    "	baþlangýcý ikincisi ise bitiþi temsil eder. Ana kontrol rölesi kullandýktan",
    "	sonra iþlevini bitirmek için ikinci bir ana kontrol rölesi eklemelisiniz.",
    "",
    "> MOVE                      {destvar :=  }      {Tret :=     }",
    "                           -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "    Giriþi 1 olduðunda verilen sabit sayýyý (123 gibi) yada verilen deðiþkenin",
    "	içeriðini (srcvar) belirtilen deðiþkene (destvar) atar. Giriþ 0 ise herhangi",
    "	bir iþlem olmaz. Bu komut ile zamanlayýcý ve sayýcýlar da dahil olmak üzere",
    "	tüm deðiþkenlere deðer atayabilirsiniz. Örneðin Tsay zamanlayýcýsýna MOVE ile",
    "	0 atamak ile RES ile sýfýrlamak ayný sonucu doðurur. Bu komut bir satýrýn",
    "	saðýndaki en son komut olmalýdýr.",
    "",
    "> MATEMATÝK ÝÞLEMLER         {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                            {MUL  dest :=}       {DIV  dv :=  }",
    "                            -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "    Bu komutun giriþi doðru ise belirtilen hedef deðiþkenine verilen matematik",
    "	iþlemin sonucunu kaydeder. Ýþlenen bilgi zamanlayýcý ve sayýcýlar dahil",
    "	olmak üzere deðiþkenler yada sabit sayýlar olabilir. Ýþlenen bilgi 16 bit",
    "	iþaretli sayýdýr. Her çevrimde iþlemin yeniden yapýldýðý unutulmamalýdýr.",
    "	Örneðin artýrma yada eksiltme yapýyorsanýz yükselen yada düþen kenar",
    "	kullanmanýz gerekebilir. Bölme (DIV) virgülden sonrasýný keser. Örneðin;",
    "	8 / 3 = 2 olur. Bu komut bir satýrýn saðýndaki en son komut olmalýdýr.",
    "",
    "",
    "> KARÞILAÞTIRMA         [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]       [-4 <   ]       [1 <=]",
    "                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-",
    "",
    "    Deðiþik karþýlaþtýrma komutlarý vardýr. Bu komutlarýn giriþi doðru (1)",
    "	ve verilen þart da doðru ise çýkýþlarý 1 olur.",
    "",
    "",
    "> SAYICI                       Cname          Cname",
    "                           --[CTU >=5]--  --[CTD >=5]--",
    "",
    "    Sayýcýlar giriþlerinin 0'dan 1'e her geçiþinde yani yükselen kenarýnda",
    "	deðerlerini 1 artýrýr (CTU) yada eksiltirler (CTD). Verilen þart doðru ise",
    "	çýkýþlarý aktif (1) olur. CTU ve CTD sayýcýlarýna ayný ismi erebilirsiniz.",
    "	Böylece ayný sayýcýyý artýrmýþ yada eksiltmiþ olursunuz. RES komutu sayýcýlarý",
    "	sýfýrlar. Sayýcýlar ile genel deðiþkenlerle kullandýðýnýz komutlarý kullanabilirsiniz.",
    "",
    "",
    "> DAÝRESEL SAYICI              Cname",
    "                           --{CTC 0:7}--",
    "",
    "    Normal yukarý sayýcýdan farký belirtilen limite ulaþýnca sayýcý tekrar 0'dan baþlar",
    "    Örneðin sayýcý 0, 1, 2, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 2,.... þeklinde",
    "	sayabilir. Yani bir dizi sayýcý olarak düþünülebilir. CTC sayýcýlar giriþlerinin",
    "	yükselen kenarýnda deðer deðiþtirirler. Bu komut bir satýrýn saðýndaki",
    "	en son komut olmalýdýr.",
    "    ",
    "",
    "",
    "MATEMATÝKSEL ÝÞLEMLER ÝLE ÝLGÝLÝ BÝLGÝ",
    "======================================",
    "",
    "Unutmayýn ki, POPTools 16-bit tamsayý matematik komutlarýna sahiptir.",
    "Bu iþlemlerde kullanýlan deðerler ve hesaplamanýn sonucu -32768 ile",
    "32767 arasýnda bir tamsayý olabilir.",
    "",
    "Mesela y = (1/x)*1200 formülünü hesaplamaya çalýþalým. x 1 ile 20",
    "arasýnda bir sayýdýr. Bu durumda y 1200 ile 60 arasýnda olur. Bu sayý",
    "16-bit bir tamsayý sýnýrlarý içindedir. Ladder diyagramýmýzý yazalým.",
    "Önce bölelim, sonra çarpma iþlemini yapalým:",
    "",
    "   ||         {DIV  temp  :=}          ||",
    "   ||---------{ 1 / x       }----------||",
    "   ||                                  ||",
    "   ||          {MUL  y  :=  }          ||",
    "   ||----------{ temp * 1200}----------||",
    "   ||                                  ||",
    "",
    "Yada bölmeyi doðrudan yapalým:",
    "",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ 1200 / x }-----------||",
    "",
    "Matematiksel olarak iki iþlem aynýd sonucu vermelidir. Ama birinci iþlem",
    "yanlýþ sonuç verecektir. (y=0 olur). Bu hata `temp' deðiþkeninin 1'den",
    "küçük sonuç vermesindendir.Mesela x = 3 iken (1 / x) = 0.333 olur. Ama",
    "0.333 bir tamsayý deðildir. Bu nedenle sonuç 0 olur. Ýkinci adýmda ise",
    "y = temp * 1200 = 0 olur. Ýkinci þekilde ise bölen bir tamsayý olduðundan",
    "sonuç doðru çýkacaktýr.",
    "",
    "Ýþlemlerinizde bir sorun varsa dikkatle kontrol ediniz. Ayrýca sonucun",
    "baþa dönmemesine de dikkat ediniz. Mesela 32767 + 1 = -32768 olur.",
    "32767 sýnýrý aþýlmýþ olacaktýr. ",
    "",
    "Hesaplamalarýnýzda mantýksal deðiþimler yaparak doðru sonuçlar elde edebilirsiniz.",
    "Örneðin; y = 1.8*x ise formülünüzü y = (9/5)*x þeklinde yazýnýz.(1.8 = 9/5)",
    "y = (9*x)/5 þeklindeki bir kod sonucu daha tutarlý hale getirecektir.",
    "performing the multiplication first:",
    "",
    "   ||         {MUL  temp  :=}          ||",
    "   ||---------{ x * 9       }----------||",
    "   ||                                  ||",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ temp / 5 }-----------||",
    "",
    "",
    "KODALAMA ÞEKLÝ",
    "==============",
    "",
    "Programýn saðladýðý kolaylýklardan faydalanýn. Mesela:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    "   ||-------] [------+-------( )-------||",
    "   ||                |                 ||",
    "   ||                |       Yc        ||",
    "   ||                +-------( )-------||",
    "   ||                                  ||",
    "",
    "yazmak aþaðýdakinden daha kolay olacaktýr.",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    " 2 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yc        ||",
    " 3 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "",
    "                  *                 *                  *",
    "",
    "Yazdýðýnýz kodlarýn sonuçlarýna dikkat ediniz. Aþaðýdaki satýrlarda",
    "mantýksýz bir programlama yapýlmýþtýr. Çünkü hem Xa hemde Xb ayný",
    "anda doðru olabilir.",
    "",
    "   ||       Xa         {v  :=       }  ||",
    " 1 ||-------] [--------{ 12      MOV}--||",
    "   ||                                  ||",
    "   ||       Xb         {v  :=       }  ||",
    "   ||-------] [--------{ 23      MOV}--||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||      [v >]             Yc        ||",
    " 2 ||------[ 15]-------------( )-------||",
    "   ||                                  ||",
    "",
    "Aþaðýdaki satýrlar yukarda bahsi geçen tarzdadýr. Ancak yapýlan",
    "iþlem 4-bit binary sayý tamsayýya çevrilmektedir.",
    "",
    "   ||                                   {v  :=       }  ||",
    " 3 ||-----------------------------------{ 0       MOV}--||",
    "   ||                                                   ||",
    "   ||       Xb0                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 1    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb1                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 2    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb2                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 4    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb3                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 8    }-----------||",
    "   ||                                                   ||",
    "",
    "",
    NULL
};
#endif

#if defined(LDLANG_EN) || defined(LDLANG_ES) || defined(LDLANG_IT) || defined(LDLANG_PT)
char *HelpText[] = {
    "",
    "INTRODUÇÃO",
    "============",
    "",
    "POPTools gera o código nativo para os produtos POP7 e POP9.",
    "Ladder é uma linguagem de programação gráfica, em forma de diagrama,",
    "que por ser de fácil criação e interpretação e representar ligações",
    "físicas entre componentes eletrônicos (sensores e atuadores), acaba",
    "sendo bastante utilizada em ambiente industrial.",
    "",
    "Um simples programa pode ter esta aparência:",
    "",
    "   ||                                                                    ||",
    "   ||    Xbutton1           Tdon           Rchatter           Yred       ||",
    " 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||",
    "   ||                                 |                                  ||",
    "   ||    Xbutton2           Tdof      |                                  ||",
    "   ||-------]/[---------[TOF 2.000 s]-+                                  ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||    Rchatter            Ton             Tnew           Rchatter     ||",
    " 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||------[END]---------------------------------------------------------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "",
    "(TON e um temporizador para ligar; TOF e um temporizador para desligar. ",
    "O símbolo --] [-- sao entradas, que se comportam como o contatos de um relé.",
    "O símbolo --( )-- sao saídas, que se comportam como a bobina de um rele.",
    "Muitas referências boas para a lógica ladder estão disponíveis na Internet",
    "e em outros lugares; os detalhes específicos desta aplicação segue adiante.)",
    "",
    "Em um diagrama LADDER simples, podemos encontrar três tipos de",
    "elementos básicos:",
    "",
    "1) CONTATO (Contact): É o elemento que",
    "   representa o sensor, ou seja, a entrada de sinal",
    "   no bloco de controle lógico. Pode ser uma",
    "   chave, um sensor reflexivo, um final de curso ou",
    "   até mesmo o contato de algum relé auxiliar.",
    "",
    "2) BOBINA (coiL): É o elemento atuador, ou seja, o",
    "   elemento acionado ou desligado pelo bloco de",
    "   controle lógico. Pode ser uma contactora, um",
    "   motor, uma lâmpada, um atuador auditivo, etc...",
    "",
    "3) MEMÓRIA ou Relé Interno (Internal Relay): É a",
    "   representação do estado de um contato ou",
    "   bobina em memória, sem conexão direta com",
    "   elementos externos.",
    "",
    "Uma série de diferenças são evidentes Se compararmos com uma linguagem C:",
    "",
    "    * O programa é apresentado em formato gráfico, e não como uma lista textual",
    "      de declarações. Muitas pessoas vão achar isso mais fácil inicialmente para",
    "      compreender.",
    "",
    "    * No nível mais básico, os programas parecem diagramas de circuitos, com",
    "      contatos de relé (inputs) e bobinas (saídas). Isto é intuitivo para",
    "      programadores com conhecimento da teoria de circuitos elétricos.",
    "",
    "    * O compilador de lógica ladder cuida do que e onde será calculado.",
    "      Você não tem que escrever código para determinar quando as saídas",
    "      tem que ter recalculado com base em uma mudança nas entradas ou",
    "      evento timer, e você não precisa especificar a ordem em que",
    "      estes cálculos devem ter lugar, o programa faz isso por você.",
    "",
    "Usando POPTools, você pode desenhar um diagrama ladder para o seu programa. Você pode",
    "simular a lógica em tempo real no seu PC. Então, quando você está convencido",
    "que ele está correto pode atribuir pinos do microcontrolador para o",
    "inputs e outputs do programa. Depois de ter atribuído os pinos, você pode",
    "compilar o código para seu programa. A saída do compilador é um arquivo .hex",
    "que você pode gravar diretamente na POP.",
    "",
    "POPTools é projetado para ser um pouco semelhante à maioria dos PLC comerciais.",
    "Aqui estão algumas excepções, e um monte de coisas que ",
    "não são padrão na indústria de qualquer maneira. Leia atentamente a descrição",
    "de cada instrução, mesmo se lhe parece familiar. Este documento assume",
    "conhecimentos básicos de lógica ladder e da estrutura de software PLC",
    "(O ciclo de execução: ler entradas, calcular, escrever saidas).",
    "",
    "",
    "BASICO",
    "======",
    "",
    "Se você executar POPTools sem argumentos, então ele começa com um programa vazio.",
    "Se você executar POPTools com o nome de um programa ladder (xxx.ld)",
    "na linha de comando, então ele irá tentar carregar o programa na inicialização.",
    "POPTools usa seu próprio formato interno para o programa, não pode importar",
    "lógica de qualquer outra ferramenta.",
    "",
    "Se você não carregar um programa já existente, será carregado um programa",
    "com uma linha vazia. Você pode adicionar uma instrução para que, por exemplo",
    "você pode adicionar um conjunto de contatos (Instrução -> Inserir Contactos) nomeado",
    "`Xnew'. `X' significa que os contatos serão vinculados a um pino de entrada no",
    "PLC. Você pode deixar para atribuir uma porta mais tarde, depois de renomear os ",
    "contator. A primeira letra de um nome indica o tipo de objeto. Por exemplo:",
    "indicates what kind of object it is.  For example:",
    "",
    "    * Xname -- relacionado a uma porta de entrada no PLC",
    "    * Yname -- relacionado a uma porta de saida no PLC",
    "    * Rname -- `relê interno': 1 bit na memória",
    "    * Tname -- temporizador",
    "    * Cname -- contador",
    "    * Aname -- um inteiro lido do conversor A/D",
    "    * name  -- variável inteira de propósito geral",
    "",
    "Escolha o resto do nome para que descreve o que o objeto faz, que seja",
    "único dentro do programa. O mesmo nome refere-se sempre ao mesmo objeto no programa.",
    "Por exemplo, seria um erro ter um temporizador para ligar (TON) chamado `Tdelay'",
    "e um temporizador para desligar (TOF) chamado `Tdelay' no mesmo programa",
    ", uma vez que cada contador precisa de sua própria memória.",
    "Por outro lado, seria correto ter um temporizador retentivo",
    "(RTO) chamado `Tdelay' e uma instrução reset (RES), associada com `Tdelay'",
    ",pois nesse caso, você quer trabalhar com o mesmo temporizador.",
    "",
    "Os nomes de variáveis podem consistir de letras, números e sublinhados",
    "(_). Um nome de variável não deve começar com um número. Os nomes de variáveis são",
    "sensíveis a maiúsculas e minúsculas.",
    "",
    "As instruções para variáveis de uso geral (MOV, ADD, EQU, etc) podem trabalhar com",
    "variáveis de qualquer nome. Isso significa que eles podem acessar temporizador e",
    "contadores. Isso pode às vezes ser útil, por exemplo, você",
    "poderia verificar se a contagem de um temporizador esta em um determinado intervalo.",
    "",
    "As variáveis são sempre inteiros de 32 bit. Isto significa que eles podem ir",
    "de -2147483648 to 2147483647. As variáveis são sempre tratados com sinal. Você pode",
    "especificar literais como normal os números decimais (0, 1.234, -56). Você também pode",
    "especificar valores de caracteres ASCII ('A', 'z'), colocando o caracter em",
    "aspas simples. Você pode usar um código de caracteres ASCII na maioria dos lugares que",
    "você poderia usar um número decimal.",
    "",
    "Na parte inferior da tela você verá uma lista de todos os objetos do programa",
    "Esta lista é gerada automaticamente a partir do programa;",
    "não há necessidade para mantê-lo atualizado manualmente. A maioria dos objetos não",
    "necessidade de qualquer configuração. `Xname', `Yname', and `Aname' deve ser",
    "atribuído a uma porta do PLC. Em seguida, atribua suas portas de entrada e saida",
    "clicando duas vezes-los na lista.",
    "",
    "Você pode modificar o programa de inserção ou exclusão de instruções.",
    "O cursor no pisca na tela do programa para indicar a instrução selecionada",
    "e o ponto de inserção atual. Se ele não estiver piscando, em seguida,",
    "pressione <Tab> ou clique em uma instrução. Agora você pode excluir a instrução atual,",
    "ou você pode inserir uma nova instrução para a direita ou esquerda",
    "(em série), ou acima ou abaixo (em paralelo) com a instrução selecionada.",
    "Algumas operações não são permitidas. Por exemplo, nenhuma instrução é permitida",
    "a direita de uma bobina.",
    "",
    "Este programa inicia-se com apenas uma linha. Você pode adicionar mais linhas, selecionando",
    "Insira Linha Antes / Depois no menu Editar. Você poderia obter o mesmo efeito",
    "colocando muitas sub circuitos complicado em paralelo dentro de uma linha,",
    "mas é mais claro usar múltiplas linhas.",
    "",
    "Depois de ter escrito um programa, você pode testá-lo em simulação e, em seguida",
    "você pode compilá-lo para gerar um arquivo .HEX para o PLC.",
    "",
    "",
    "SIMULAÇÃO",
    "==========",
    "",
    "Para entrar no modo de simulação, escolha Simulação -> Modo Simulação ou pressione",
    "<Ctrl+M>. O programa é apresentado de forma diferente no modo de simulação. Não há",
    "cursor. As instruções que são energizados aparecem em vermelho brilhante;",
    "As instruções que não estão energizadas parecem esverdeadas. Pressione a barra de espaço",
    "para simular um ciclo do PLC. Para ciclo contínuo em tempo real, escolher",
    "Simular -> Iniciar Simulação em Real-Time, ou pressione <Ctrl+R>. As alterações",
    "são mostradas em tempo real conforme o programa muda.",
    "",
    "Você pode definir o estado das entradas para o programa clicando duas vezes",
    "na lista na parte inferior da tela, ou clicando duas vezes uma instrução de contato `Xname'.",
    "Se você alterar o estado de uma porta de entrada, ",
    "as alterações não serão refletidas na forma como o programa",
    "é mostrado até que um ciclo do PLC aconteça; isto ira acontecer automaticamente se",
    "você estiver executando a simulação em tempo real, ou quando você pressionar a barra de espaço.",
    "",
    "",
    "INSTRUÇÕES",
    "==========",
    "",
    "> CONTATO, NORMALMENTE ABERTO        Xname           Rname          Yname",
    "                                  ----] [----     ----] [----    ----] [----",
    "",
    "    Tecla de atalho : C",
    "    Pode ser aplicado à : Pinos de entrada, Pinos de saída, Relés internos",
    "    Se o sinal da instrução (contato) é falso, a saída de sinal também será",
    "    falsa. Interprete como uma chave com conexões em contato normalmente aberto, que",
    "    quando acionado fecha o circuito.",
    "",
    "",
    "> CONTATO, NORMALMENTE FECHADO      Xname           Rname          Yname",
    "                                 ----]/[----     ----]/[----    ----]/[----",
    "",
    "    Tecla de atalho : C",
    "    Pode ser aplicado à : Pinos de entrada, Pinos de saída, Relés internos",
    "    Se o sinal entrar de entrada for falso, a saída é verdadeira. Se o sinal de",
    "    entrada for verdadeiro, a saída é falsa. Entenda como uma chave com conexões em",
    "    contato normalmente fechado, que quando é acionada irá abrir o circuito,",
    "    interrompendo a passagem de sinal.",
    "    Esta instrução é similar a anterior, com a diferença da opção |\|Negated",
    "    ativada.",
    "",
    "",
    "> BOBINA, NORMAL                  Rname           Yname",
    "                               ----( )----     ----( )----",
    "",
   "    Tecla de atalho: L",
   "    Aplica-se à: Relé interno e pinos de saída",
   "    ",
   "    Se o sinal vindo das instruções é verdadeiro, então a saída em questão irá",
   "    ser ativada. Se o sinal é falso (circuito aberto), a saída será desativada. Esta",
   "    instrução sempre estará mais a direita possível no diagrama ladder. Podem ser",
   "    inseridas em paralelo, mas não em série.",
    "",
    "",
    "> BOBINA, NEGATED                 Rname           Yname",
    "                             ----(/)----     ----(/)----",
    "",
   "    Tecla de atalho: L",
   "    Aplica-se à: Relé interno e pinos de saída",
   "    ",
   "    Se o sinal que vai à instrução é verdadeiro, então a saída em questão é",
   "    desativada. Caso o sinal de entrada seja falso (circuito aberto), a saída será",
   "    ativada. Similar à instrução anterior com o valor invertido.",
   "    ",
    "",
    "",
    "> BOBINA, SET-ONLY                Rname           Yname",
    "                             ----(S)----     ----(S)----",
    "",
    "    Tecla de atalho: L",
    "    Aplica-se à: Relé interno e pinos de saída",
    "    ",
    "    Com esta opção, estabelece-se que a saída em questão irá ter seu estado",
    "    modificado para ATIVADO quando a entrada de sinal for verdadeira, e não",
    "    desativará quando o sinal de entrada for falso.",
    "    ",
    "",
    "",
    "> BOBINA, RESET-ONLY              Rname           Yname",
    "                             ----(R)----     ----(R)----",
    "",
    "         Se o sinal que chega a instrução for verdadeiro, então o relé interno ou",
    "   pino de saída será desativado. Caso contrário, o pino de saída ou relé interno",
    "   não terá seu estado modificado. Esta instrução somente poderá mudar o estado do",
    "   pino de LIGADO para DESLIGADO, e geralmente isso é utilizado em combinação com",
    "   uma ação BOBINA SET-ONLY. Esta instrução deve ser a mais a direita possível.",
    "    ",
    "",
    "",
    "> TURN-ON DELAY (TEMPORIZADOR)       ",
    "                                Tdon ",
    "                           -[TON 1.000 s]-",
    "",
    "    Quando o sinal que vai para a instrução comutar de DESLIGADO para LIGADO",
    "    (borda de subida), a saída permanecerá falsa por N segundos antes de ser ativado.",
    "    Quando o sinal de entrada mudar de LIGADO para DESLIGADO, a saída irá para",
    "    DESLIGADO imediatamente. O temporizador é reiniciado sempre que a entrada estiver",
    "    em nível DESLIGADO. O tempo (N) é configurável. No exemplo, o valor é de 1",
    "    segundo)",
    "",
     "    O nome ‘Tdon’ irá contar a partir de zero em unidades de scantimes. A",
    "    instrução de saída TON irá proporcionar saída em nível alto sempre que o contador",
    "    de ciclos for igual ou superior ao delay escolhido. É também possível manitular",
    "    esta variável contadora ‘Tdon’, por exemplo com instruções de manipulação de",
    "    dados como a instrução MOV.",
    "",
    "",
    "> TURN-OFF DELAY (RETARDO NO DESLIGAMENTO)",
    "    ",
    "                                 Tdoff ",
    "                           -[TOF 1.000 s]-",
    "",
    "    Quando o sinal vindo da instrução muda de LIGADO para DESLIGADO, o sinal de",
    "    saída ainda permanecerá ativado por N segundos antes de desativar. Quando o sinal",
    "    vindo da instrução mudar de DESLIGADO para LIGADO, a saída irá mudar para LIGADO",
    "    imediatamente. O temporizador é reiniciado sempre que a entrada mudar para nível",
    "    DESLIGADO. A entrada precisará estar desativada pelo tempo determinado para que a",
    "    saída mude para estado FALSO. O tempo (N) é configurável.",
    "    ",
    "    A variável ‘Tdoff’ é uma variável contadora crescente que inicia em zero, e",
    "    incrementa em unidades de tempo de ciclo. É possível manipular esta variável de",
    "    tempo através de instruções de manipulação de dados, como a instrução MOV.",
    "    ",
    "",
    "",
    "> RETENTIVE TIMER               Trto  ",
    "                           -[RTO 1.000 s]-",
    "",
    "         Esta instrução está associada ao tempo de duração do pulso da entrada. Se a",
    "    entrada permanecer ligada por mais de N segundos, a saída será ativada. Em outro",
    "    caso, a saída permanecerá falsa. A entrada precisa permanecer acionada por, no",
    "    mínimo, N segundos para ativar a saída, que uma vez ativada, assim o permanecerá",
    "    até que a variável ‘Trto’ em questão seja reiniciada, ou através de uma instrução",
    "    manual de reset.",
    "    ",
    "         É possível manipular o estado da variável contadora de tempo através de",
    "    instruções de manipulação de memória, como a instrução MOV ou RESET.",
    "    ",
    "",
    "> RESET                        Trto             Citems",
    "                           ----{RES}----     ----{RES}----",
    "",
    "        Esta instrução reinicia um timer ou contador. Retardos do tipo TON e TOF são",
    "    automaticamente reiniciados quando as suas entradas mudarem de estado, mas o",
    "    temporizador retentivo não. O temporizador RTO, contadores CTU e CTD não são",
    "    reiniciados automaticamente, e devem ser reiniciados manualmente usando a",
    "    instrução RES. Quando a entrada é verdadeira, o contador ou timer associado é",
    "    reiniciado. Esta instrução necessita ser a instrução mais a direita no degrau",
    "    ladder produzido.",
    "",
    "",
    "> ONE-SHOT RISING (BORDA DE SUBIDA) _",
    "    ",
    "                           --[OSR_/ ]--",
    "",
    "          Esta instrução produz, por padrão, saída DESLIGADA. Se o sinal de entrada",
    "    mudar durante o processo de DESLIGADO para LIGADO a saída será ativada. Isso gera",
    "    um pulso de um ciclo na saída, e pode ser usado para disparar eventos baseados na",
    "    borda de subida de um sinal.",
    "",
    "",
    "> ONE-SHOT FALLING (BORDA DE DESCIDA) _",
    "",
    "                           --[OSF \\_]--",
    "",
    "    Esta instrução produz, por padrão, saída DESLIGADA. Se o sinal de entrada",
    "    mudar durante o processo de LIGADO para DESLIGADO a saída será ativada. Isso gera",
    "    um pulso de um ciclo na saída, e pode ser usado para disparar eventos baseados na",
    "    borda de descida de um sinal.",
    "    ",
    "",
    "",
    "> SHORT CIRCUIT, OPEN CIRCUIT (CIRCUITO FECHADO, CIRCUITO ABERTO) ",
    "    ",
    "                           ----+----+----      ----+     +----",
    "",
    "    A condição de saída de um CIRCUITO FECHADO é sempre igual a sua condição de",
    "    entrada, e o estado do sinal da saída de um CIRCUITO ABERTO é sempre desligado.",
    "    Isso pode ser útil para depurar o programa em situações de análise e teste.",
    "",
    "",
    "> MASTER CONTROL RELAY (RELÉ PRINCIPAL) ",
    "                           -{MASTER RLY}-",
    "",
    "    Por padrão, todos os degraus tem condição de entrada LIGADA. Este relé",
    "    principal realiza controle esta entrada, e pode desativar estas entradas. Dentro",
    "    do ciclo do programa, podem ser adicionadas instruções para ativação e",
    "    desativação parciais do MASTER RLY, sendo isso bastante útil para depuração.",
    "    ",
    "   ",
    "",
    "",
    "> MOVE                      {destvar :=  }      {Tret :=     }",
    "                           -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "    Quando o sinal de entrada desta instrução for LIGADO, a variável de destino",
    "    será carregada com o valor da variável de origem ou da constante. Se o sinal de",
    "    entrada estiver DESLIGADO, nada acontece com a variável. Você pode utilizar a",
    "    instrução MOVE com qualquer variável, incluindo contadores e temporizadores.",
    "    Esta instrução precisa ser a mais a direita no degrau de instruções.",
    "",
    "",
    "> OPERAÇÃO ARITMÉTICA        {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                            {MUL  dest :=}       {DIV  dv :=  }",
    "                            -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "    Quando o sinal de entrada desta instrução é verdadeiro, a variável de",
    "    destino é carregada com o resultado da expressão. Isso pode ser realizado também",
    "    em variáveis de contagem e temporizadores. Estas instruções aritméticas utilizam",
    "    um processamento aritmético de números 16 bits com sinal. Cada ciclo de",
    "    processamento desencadeia uma operação aritmética, caso o sinal de entrada esteja",
    "    verdadeiro. Se você usar esta instrução para incrementar ou decrementar uma",
    "    variável, e isso estiver associado a um sinal de entrada (tipo um botão), use a",
    "    instrução de borda de subida ou descida para que o incremento ou decremento",
    "    ocorra somente em uma operação por pulso de entrada. A divisão é truncada, e não",
    "    arredondada. 8 / 3 resulta em 2.",
    "    Esta instrução precisa ser a mais a direita no bloco (degrau) em uso.",
    "",
    "",
    "> COMPARE(COMPARAÇÃO)   [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]       [-4 <   ]       [1 <=]",
    "                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-",
    "",
    "    Se o sinal de entrada para esta instrução é DESLIGADO, então a saída também",
    "    é DESLIGADA. Se o sinal de entrada for LIGADO, então a saída será LIGADA se e",
    "    somente se a instrução de comparação for verdadeira. Esta instrução pode ser",
    "    usada para comparação (igual, maior que, maior e igual, diferente, menor que,",
    "    menor e igual) entre variáveis, ou para comparar uma variável com uma constante",
    "    numérica de 16 bits.",
    "",
    "",
    "> COUNTER  (CONTADOR)          Cname          Cname",
    "                           --[CTU >=5]--  --[CTD >=5]--",
    "",
    "    Um contador incremental (CTU, conut up) ou decrementa (CTD, count down) é",
    "    associado à deteção de borda de uma determinada condição de entrada. O sinal de",
    "    saída desta instrução é verdadeiro caso o valor do contador tenha atingido o",
    "    valor limite.",
    "    Você pode utilizar instrução de incremento (CTU) e decremento (CTD) com",
    "    variáveis de mesmo nome, e a instrução RES para reiniciar o valor do mesmo.",
    "",
    "",
    "> CIRCULAR COUNTER (CIRCULAR COUNTER)",
    ">                              Cname",
    "                           --{CTC 0:7}--",
    "",
    "    Um contador circular trabalha como um contador normal, exceto pelo fato de,",
    "    após atingir o limite, ele reinicia voltando ao valor inicial. Por exemplo, o",
    "    contador acima, se incrementado, contará 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4,",
    "    5, 6, 7, 0, 1, 2, ...",
    "    Isso pode ser muito útil se combinado com estruturas condicionais na",
    "    variável ‘Cname’, podendo ser criado o efeito de seqüenciador. CTC conta na borda",
    "    de subida do sinal de entrada, e esta instrução deve ser a mais a direita no",
    "    bloco (degrau) ladder.",
    "",
    "",
    "> SHIFT REGISTER            {SHIFT REG   }",
    "                           -{ reg0..3    }-",
    "",
    "    Um SHIFT REGISTER (Registrador de deslocamento) é associado a um grupo de",
    "    variáveis. Por exemplo, este registrador pode ser associado com as variáveis",
    "    ‘reg0’, ‘reg1’, ‘reg2’ e ‘reg3’.",
    "    A cada pulso (borda de subida) na entrada desta instrução, ocorre o",
    "    deslocamento (reg3 ? reg2, reg2 ? reg1, reg1 ? reg0, e reg0 permanece",
    "    inalterado).",
    "    Observe que esta instrução consome uma área significativa de memória, e",
    "    deve ser usada com cuidado.",
    "    Ela precisa ser a instrução mais à direita no degrau em uso.",
    "",
    "",
    "",
    "> LOOK-UP TABLE             {dest :=     }",
    "                           -{ LUT[i]     }-",
    "",
    "    Uma tabela look-up é um conjunto de n dados ordenados. Quando a condição de",
    "    entrada for LIGADO, a variável de destino ‘dest’ será carregada com o valor da",
    "    variável de origem na ocorrência ‘i’. O índice (i) inicia em zero. Esta instrução",
    "    deve ser a mais a direita no degrau em uso.",
    "    ",
    "",
    "",
    "> PIECEWISE LINEAR TABLE    {yvar :=     }",
    "                           -{ PWL[xvar]  }-",
    "",
    "    Esta é a melhor forma de aproximar uma complicada função de transformação",
    "    não linear. Pode ser útil, por exemplo, se você tiver que associar os valores",
    "    lidos a uma curva de calibração baseado no valor de entrada de um sensor.",
    "    Você pode entrar com dados na tabela associando com um valor linear",
    "    desejado. O valor será atribuído a variável xvar, e isso define o valor da",
    "    valores.",
    "",
    "    Os pontos precisam ser especificados em ordem crescente em xvar. Em alguns",
    "    casos, por questões matemáticas e de limitações do processamento aritmético de 16",
    "    bits, o LDmicro poderá gerar mensagens de erro relativas a conversão. Neste caso,",
    "    adicione mais dados à tabela.",
    "    Ex: Isso irá produzir um erro, se lançado estes dois pontos:",
    "",
    "        f(0)   = 2",
    "        f(5)   = 10",
    "        f(10)  = 50",
    "        f(100) = 100",
    "",
    "    TQue pode ser corrigido desta forma:",
    "",
    "        (x0, y0)   = (  0,   2)",
    "        (x1, y1)   = (  5,  10)",
    "        (x2, y2)   = ( 10,  50)",
    "        (x3, y3)   = (100, 100)",
    "",
    "    Em casos extremos pode ser necessário usar mais de cinco ou seis pontos.",
    "    Adicionando mais pontos o código fica maior e mais lento para ser executado",
    "    A instrução precisa ser a mais à direita do degrau em uso.",
    "",
    "",
    "> A/D CONVERTER READ           Aname",
    "                           --{READ ADC}--",
    "",
    "    POPTools pode gerar código para usar o conversor A/D do CLP",
    "    Se a condição de entrada para esta instrução é LIGADO, então",
    "    será obtida uma simples amostra do conversor A/D e isso é armazenado na variável",
    "    chamada ‘Aname’. Testa variável pode ser manipulada com operações genéricas, como",
    "    comparação e atribuição.",
    "    Associe o pino à variável ‘Axxx’ da mesma forma que é associado um pino de",
    "    entrada/saída digital, clicando duplamente na parte inferior da tela.",
    "    Entradas de 0 Volts corresponde ao valor 0, e uma entrada na tensão máxima",
    "    do sistema (Vdd) corresponde ao valor 1023 (AD de 10 bits).",
    "    O software não irá permitir que você associe pinos que não sejam entradas anlógicas",
    "",
    "",
    "> SET PWM DUTY CYCLE          duty_cycle",
    "                           -{PWM 32.8 kHz}-",
    "",
    "    POPTools can generate code to use the PWM peripheral built in to",
    "    certain microcontrollers. If the input condition to this instruction",
    "    is true, then the duty cycle of the PWM peripheral is set to the",
    "    value of the variable duty_cycle. The duty cycle must be a number",
    "    between 0 and 100; 0 corresponds to always low, and 100 corresponds to",
    "    always high. (If you are familiar with how the PWM peripheral works,",
    "    then notice that that means that POPTools automatically scales the",
    "    duty cycle variable from percent to PWM clock periods.)",
    "",
    "    You can specify the target PWM frequency, in Hz. The frequency that",
    "    you specify might not be exactly achievable, depending on how it",
    "    divides into the microcontroller's clock frequency. POPTools will",
    "    choose the closest achievable frequency; if the error is large then",
    "    it will warn you. Faster speeds may sacrifice resolution.",
    "",
    "    This instruction must be the rightmost instruction in its rung.",
    "    The ladder logic runtime consumes one timer to measure the cycle",
    "    time. That means that PWM is only available on microcontrollers",
    "    with at least two suitable timers. PWM uses pin CCP2 (not CCP1)",
    "    on PIC16 chips and OC2 (not OC1A) on AVRs.",
    "",
    "",
    "> MAKE PERSISTENT            saved_var",
    "                           --{PERSIST}--",
    "",
    "    Quando a instrução de entrada é LIGADA, isso fará com que determinada",
    "    variável seja salva na EEPROM. Isso significa que o valor persistirá quando o",
    "    sistema for desativado (desconectado da energia elétrica).",
    "    Não é necessário declarar o local onde a informação será gravada, isso",
    "    ocorrerá de forma automática, e a variável será automaticamente carregada quanto",
    "    o sistema for reiniciado.",
    "    Se o sistema abusar deste recurso, gravando muito freqüentemente na eeprom,",
    "    então este recurso pode ser danificado, pois muitos sistemas garantem um limite",
    "    de 100000 gravações somente.",
    "",
    "",
    "> RS485 (SERIAL) RECEIVE          var",
    "                           --{UART RECV}--",
    "",
    "    POPTools can generate code to use the UART built in to certain",
    "    microcontrollers. On AVRs with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; POPTools will warn you if this is the case.",
    "",
    "    If the input condition to this instruction is false, then nothing",
    "    happens. If the input condition is true then this instruction tries",
    "    to receive a single character from the UART. If no character is read",
    "    then the output condition is false. If a character is read then its",
    "    ASCII value is stored in `var', and the output condition is true",
    "    for a single PLC cycle.",
    "",
    "",
    "> RS485 (SERIAL) SEND             var",
    "                           --{UART SEND}--",
    "",
    "    POPTools can generate code to use the UARTs built in to certain",
    "    microcontrollers. On AVRS with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; POPTools will warn you if this is the case.",
    "",
    "    If the input condition to this instruction is false, then nothing",
    "    happens. If the input condition is true then this instruction writes",
    "    a single character to the UART. The ASCII value of the character to",
    "    send must previously have been stored in `var'. The output condition",
    "    of the rung is true if the UART is busy (currently transmitting a",
    "    character), and false otherwise.",
    "",
    "    Remember that characters take some time to transmit. Check the output",
    "    condition of this instruction to ensure that the first character has",
    "    been transmitted before trying to send a second character, or use",
    "    a timer to insert a delay between characters. You must only bring",
    "    the input condition true (try to send a character) when the output",
    "    condition is false (UART is not busy).",
    "",
    "    Investigate the formatted string instruction (next) before using this",
    "    instruction. The formatted string instruction is much easier to use,",
    "    and it is almost certainly capable of doing what you want.",
    "",
    "",
    "> FORMATTED STRING OVER UART                var",
    "                                   -{\"Pressure: \\3\\r\\n\"}-",
    "",
    "    POPTools can generate code to use the UARTs built in to certain",
    "    microcontrollers. On AVRS with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; POPTools will warn you if this is the case.",
    "",
    "    When the rung-in condition for this instruction goes from false to",
    "    true, it starts to send an entire string over the serial port. If",
    "    the string contains the special sequence `\\3', then that sequence",
    "    will be replaced with the value of `var', which is automatically",
    "    converted into a string. The variable will be formatted to take",
    "    exactly 3 characters; for example, if `var' is equal to 35, then",
    "    the exact string printed will be `Pressure:  35\\r\\n' (note the extra",
    "    space). If instead `var' were equal to 1432, then the behaviour would",
    "    be undefined, because 1432 has more than three digits. In that case",
    "    it would be necessary to use `\\4' instead.",
    "",
    "    If the variable might be negative, then use `\\-3d' (or `\\-4d'",
    "    etc.) instead. That will cause POPTools to print a leading space for",
    "    positive numbers, and a leading minus sign for negative numbers.",
    "",
    "    If multiple formatted string instructions are energized at once",
    "    (or if one is energized before another completes), or if these",
    "    instructions are intermixed with the UART TX instructions, then the",
    "    behaviour is undefined.",
    "",
    "    It is also possible to use this instruction to output a fixed string,",
    "    without interpolating an integer variable's value into the text that",
    "    is sent over serial. In that case simply do not include the special",
    "    escape sequence.",
    "",
    "    Use `\\\\' for a literal backslash. In addition to the escape sequence",
    "    for interpolating an integer variable, the following control",
    "    characters are available:",
    "        * \\r   -- carriage return",
    "        * \\n   -- newline",
    "        * \\f   -- formfeed",
    "        * \\b   -- backspace",
    "        * \\xAB -- character with ASCII value 0xAB (hex)",
    "",
    "    The rung-out condition of this instruction is true while it is",
    "    transmitting data, else false. This instruction consumes a very",
    "    large amount of program memory, so it should be used sparingly. The",
    "    present implementation is not efficient, but a better one will",
    "    require modifications to all the back-ends.",
    "",
    "",
    "Observações ao usar recursos matemáticos",
    "========================================",
    "",
    "Lembre que o POPTools realiza somente instruções matemáticas com inteiros de",
    "32 bits. Isso significa que o resultado final de qualquer cálculo que for",
    "realizado deverá ser um valor inteiro entre -2147483648 and 2147483647.",
    "Isso também quer dizer que valores intermediários de cálculos tambem",
    "devem permanecer nesta faixa.", 
    "Por exmeplo, supondo que você queira calcular y = (1/x)*1200, onde x é um",
    "valor entre 1 e 20. Então y poderá valer 1200 a 60, armazenados em uma variável",
    "inteira de 32 bits. Para isso ser calculado, teoricamente há duas maneiras de se",
    "escrever o código:",
    "you can perform the reciprocal, and then multiply:",
    "",
    "   ||         {DIV  temp  :=}          ||",
    "   ||---------{ 1 / x       }----------||",
    "   ||                                  ||",
    "   ||          {MUL  y  :=  }          ||",
    "   ||----------{ temp * 1200}----------||",
    "   ||                                  ||",
    "",
    "Ou pode realizar a divisão em um passo único :",
    "",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ 1200 / x }-----------||",
    "",
    "",
    "Matematicamente, as duas são equivalents. Mas se você testá-las, poderá",
    "observar que a primeira sempre dará o incorreto resultado de y = 0. Isso é porque",
    "a variável ‘temp’ somente armazenará valores inteiros, e o resultado do primeiro",
    "degrau (1 / x) geralmente será um número menor que 1 (para x = 3, tempo será",
    "0,3333...) e isso não é possível de se armazenar em uma variável inteira.",
    "",
    "Se você estiver tendo problemas nos resultados de suas equações, verifique",
    "portanto os valores intermediários, observando se nenhum valor gerado irá",
    "resultar em dados não armazenáveis em variáveis de 32 bits com sinal.",
    "",
    "Quando você precisar multiplicar uma variável por uma fração, use isso",
    "usando respectivamente as instruções de multiplicação e divisão. Por exemplo,",
    "para multiplicar y por 1.8 * x, calcule: y = (9/5)*x (lembrando que 9/5 = 1.8).",
    "E, no código ladder, faça a multiplicação ocorrer antes da divisão.",
    "",
    "   ||         {MUL  temp  :=}          ||",
    "   ||---------{ x * 9       }----------||",
    "   ||                                  ||",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ temp / 5 }-----------||",
    "",
    "Isso funcionará para qualquer x < (32767 / 9), ou x < 3640. Para valores",
    "maiores de x, a variável ‘temp’ irá sair de seu limite.",
    "",
    "",
    "Estilos de Codificação",
    "======================",
    "",
    "É permitido múltiplas bobinas em paralelo em um simples degrau. Isso",
    "significa que você pode fazer coisas como isso:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    "   ||-------] [------+-------( )-------||",
    "   ||                |                 ||",
    "   ||                |       Yc        ||",
    "   ||                +-------( )-------||",
    "   ||                                  ||",
    "",
    "No lugar disso:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    " 2 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yc        ||",
    " 3 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "",
    "Isso permite que, em teoria, você possa escrever programas em um único",
    "degrau gigante. Na prática isso pode não ser uma boa idéia, porque os degraus",
    "ficarão mais complexos e mais difíceis de serem editados, lidos e interpretados.",
    "",
    "Still, it is often a good idea to group related logic together as a single",
    "rung. This generates nearly identical code to if you made separate rungs,",
    "but it shows that they are related when you look at them on the ladder",
    "diagram.",
    "",
    "                  *                 *                  *",
    "",
    "In general, it is considered poor form to write code in such a way that",
    "its output depends on the order of the rungs. For example, this code",
    "isn't very good if both Xa and Xb might ever be true:",
    "",
    "   ||       Xa         {v  :=       }  ||",
    " 1 ||-------] [--------{ 12      MOV}--||",
    "   ||                                  ||",
    "   ||       Xb         {v  :=       }  ||",
    "   ||-------] [--------{ 23      MOV}--||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||      [v >]             Yc        ||",
    " 2 ||------[ 15]-------------( )-------||",
    "   ||                                  ||",
    "",
    "I will break this rule if in doing so I can make a piece of code",
    "significantly more compact, though. For example, here is how I would",
    "convert a 4-bit binary quantity on Xb3:0 into an integer:",
    "",
    "   ||                                   {v  :=       }  ||",
    " 3 ||-----------------------------------{ 0       MOV}--||",
    "   ||                                                   ||",
    "   ||       Xb0                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 1    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb1                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 2    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb2                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 4    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb3                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 8    }-----------||",
    "   ||                                                   ||",
    "",
    "If the MOV statement were moved to the bottom of the rung instead of the",
    "top, then the value of v when it is read elsewhere in the program would",
    "be 0. The output of this code therefore depends on the order in which",
    "the instructions are evaluated. Considering how cumbersome it would be",
    "to code this any other way, I accept that.",
    "",
    "",
    "",
    NULL
};
#endif

