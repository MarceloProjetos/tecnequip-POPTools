#include "poptools.h"

extern char *HelpText[];

void OpenCHM(unsigned int hID)
{
	char szParam   [MAX_PATH] = "";
	char szAppPath [MAX_PATH] = "";
	char szHelpFile[MAX_PATH] = "";

	::GetModuleFileName(0, szAppPath, sizeof(szAppPath) - 1);
	strncpy(szHelpFile, szAppPath, strrchr(szAppPath, '\\') - szAppPath);
	strcat(szHelpFile, "\\Ajuda.chm");

	if(hID) {
		sprintf(szParam, "-mapid %d %s", hID, szHelpFile);
	} else {
		strcpy(szParam, szHelpFile);
	}

	ShellExecute(0,"open","HH",szParam,NULL,SW_SHOW);
}

void OpenCHM(void)
{
	OpenCHM(0);
}

static char **Text[] = 
{
	#if defined(LDLANG_EN) || \
		defined(LDLANG_ES) || \
		defined(LDLANG_IT) || \
		defined(LDLANG_PT)
		HelpText,
	#else
		#   error "Bad language"
	#endif
};

#if defined(LDLANG_EN) || defined(LDLANG_ES) || defined(LDLANG_IT) || defined(LDLANG_PT)
char *HelpText[] = {
    "",
  /*  "INTRODUÇÃO",
    "============",
    "",
    "POPTools gera o código nativo para os produtos POP7 e POP9.",
    "Ladder é uma linguagem de programação gráfica, em forma de diagrama,",
    "que por ser de fácil criação e interpretação e representar ligações",
    "físicas entre componentes eletrônicos (sensores e atuadores), acaba",
    "sendo bastante utilizada em ambiente industrial.",
    "",
    "Um simples programa pode ter esta aparência:",
    "",
    "   ||                                                                    ||",
    "   ||    Xbutton1           Tdon           Rchatter           Yred       ||",
    " 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||",
    "   ||                                 |                                  ||",
    "   ||    Xbutton2           Tdof      |                                  ||",
    "   ||-------]/[---------[TOF 2.000 s]-+                                  ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||    Rchatter            Ton             Tnew           Rchatter     ||",
    " 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "   ||------[END]---------------------------------------------------------||",
    "   ||                                                                    ||",
    "   ||                                                                    ||",
    "",
    "(TON e um temporizador para ligar; TOF e um temporizador para desligar. ",
    "O símbolo --] [-- sao entradas, que se comportam como o contatos de um relé.",
    "O símbolo --( )-- sao saídas, que se comportam como a bobina de um rele.",
    "Muitas referências boas para a lógica ladder estão disponíveis na Internet",
    "e em outros lugares; os detalhes específicos desta aplicação segue adiante.)",
    "",
    "Em um diagrama LADDER simples, podemos encontrar três tipos de",
    "elementos básicos:",
    "",
    "1) CONTATO (Contact): É o elemento que",
    "   representa o sensor, ou seja, a entrada de sinal",
    "   no bloco de controle lógico. Pode ser uma",
    "   chave, um sensor reflexivo, um final de curso ou",
    "   até mesmo o contato de algum relé auxiliar.",
    "",
    "2) BOBINA (coiL): É o elemento atuador, ou seja, o",
    "   elemento acionado ou desligado pelo bloco de",
    "   controle lógico. Pode ser uma contactora, um",
    "   motor, uma lâmpada, um atuador auditivo, etc...",
    "",
    "3) MEMÓRIA ou Relé Interno (Internal Relay): É a",
    "   representação do estado de um contato ou",
    "   bobina em memória, sem conexão direta com",
    "   elementos externos.",
    "",
    "Uma série de diferenças são evidentes Se compararmos com uma linguagem C:",
    "",
    "    * O programa é apresentado em formato gráfico, e não como uma lista textual",
    "      de declarações. Muitas pessoas vão achar isso mais fácil inicialmente para",
    "      compreender.",
    "",
    "    * No nível mais básico, os programas parecem diagramas de circuitos, com",
    "      contatos de relé (inputs) e bobinas (saídas). Isto é intuitivo para",
    "      programadores com conhecimento da teoria de circuitos elétricos.",
    "",
    "    * O compilador de lógica ladder cuida do que e onde será calculado.",
    "      Você não tem que escrever código para determinar quando as saídas",
    "      tem que ter recalculado com base em uma mudança nas entradas ou",
    "      evento timer, e você não precisa especificar a ordem em que",
    "      estes cálculos devem ter lugar, o programa faz isso por você.",
    "",
    "Usando POPTools, você pode desenhar um diagrama ladder para o seu programa. Você pode",
    "simular a lógica em tempo real no seu PC. Então, quando você está convencido",
    "que ele está correto pode atribuir pinos do microcontrolador para o",
    "inputs e outputs do programa. Depois de ter atribuído os pinos, você pode",
    "compilar o código para seu programa. A saída do compilador é um arquivo .hex",
    "que você pode gravar diretamente na POP.",
    "",
    "POPTools é projetado para ser um pouco semelhante à maioria dos PLC comerciais.",
    "Aqui estão algumas excepções, e um monte de coisas que ",
    "não são padrão na indústria de qualquer maneira. Leia atentamente a descrição",
    "de cada instrução, mesmo se lhe parece familiar. Este documento assume",
    "conhecimentos básicos de lógica ladder e da estrutura de software PLC",
    "(O ciclo de execução: ler entradas, calcular, escrever saidas).",
    "",
    "",
    "BASICO",
    "======",
    "",
    "Se você executar POPTools sem argumentos, então ele começa com um programa vazio.",
    "Se você executar POPTools com o nome de um programa ladder (xxx.ld)",
    "na linha de comando, então ele irá tentar carregar o programa na inicialização.",
    "POPTools usa seu próprio formato interno para o programa, não pode importar",
    "lógica de qualquer outra ferramenta.",
    "",
    "Se você não carregar um programa já existente, será carregado um programa",
    "com uma linha vazia. Você pode adicionar uma instrução para que, por exemplo",
    "você pode adicionar um conjunto de contatos (Instrução -> Inserir Contactos) nomeado",
    "`Xnew'. `X' significa que os contatos serão vinculados a um pino de entrada no",
    "PLC. Você pode deixar para atribuir uma porta mais tarde, depois de renomear os ",
    "contator. A primeira letra de um nome indica o tipo de objeto. Por exemplo:",
    "indicates what kind of object it is.  For example:",
    "",
    "    * Xname -- relacionado a uma porta de entrada no PLC",
    "    * Yname -- relacionado a uma porta de saida no PLC",
    "    * Rname -- `relê interno': 1 bit na memória",
    "    * Tname -- temporizador",
    "    * Cname -- contador",
    "    * Aname -- um inteiro lido do conversor A/D",
    "    * name  -- variável inteira de propósito geral",
    "",
    "Escolha o resto do nome para que descreve o que o objeto faz, que seja",
    "único dentro do programa. O mesmo nome refere-se sempre ao mesmo objeto no programa.",
    "Por exemplo, seria um erro ter um temporizador para ligar (TON) chamado `Tdelay'",
    "e um temporizador para desligar (TOF) chamado `Tdelay' no mesmo programa",
    ", uma vez que cada contador precisa de sua própria memória.",
    "Por outro lado, seria correto ter um temporizador retentivo",
    "(RTO) chamado `Tdelay' e uma instrução reset (RES), associada com `Tdelay'",
    ",pois nesse caso, você quer trabalhar com o mesmo temporizador.",
    "",
    "Os nomes de variáveis podem consistir de letras, números e sublinhados",
    "(_). Um nome de variável não deve começar com um número. Os nomes de variáveis são",
    "sensíveis a maiúsculas e minúsculas.",
    "",
    "As instruções para variáveis de uso geral (MOV, ADD, EQU, etc) podem trabalhar com",
    "variáveis de qualquer nome. Isso significa que eles podem acessar temporizador e",
    "contadores. Isso pode às vezes ser útil, por exemplo, você",
    "poderia verificar se a contagem de um temporizador esta em um determinado intervalo.",
    "",
    "As variáveis são sempre inteiros de 32 bit. Isto significa que eles podem ir",
    "de -2147483648 to 2147483647. As variáveis são sempre tratados com sinal. Você pode",
    "especificar literais como normal os números decimais (0, 1.234, -56). Você também pode",
    "especificar valores de caracteres ASCII ('A', 'z'), colocando o caracter em",
    "aspas simples. Você pode usar um código de caracteres ASCII na maioria dos lugares que",
    "você poderia usar um número decimal.",
    "",
    "Na parte inferior da tela você verá uma lista de todos os objetos do programa",
    "Esta lista é gerada automaticamente a partir do programa;",
    "não há necessidade para mantê-lo atualizado manualmente. A maioria dos objetos não",
    "necessidade de qualquer configuração. `Xname', `Yname', and `Aname' deve ser",
    "atribuído a uma porta do PLC. Em seguida, atribua suas portas de entrada e saida",
    "clicando duas vezes-los na lista.",
    "",
    "Você pode modificar o programa de inserção ou exclusão de instruções.",
    "O cursor no pisca na tela do programa para indicar a instrução selecionada",
    "e o ponto de inserção atual. Se ele não estiver piscando, em seguida,",
    "pressione <Tab> ou clique em uma instrução. Agora você pode excluir a instrução atual,",
    "ou você pode inserir uma nova instrução para a direita ou esquerda",
    "(em série), ou acima ou abaixo (em paralelo) com a instrução selecionada.",
    "Algumas operações não são permitidas. Por exemplo, nenhuma instrução é permitida",
    "a direita de uma bobina.",
    "",
    "Este programa inicia-se com apenas uma linha. Você pode adicionar mais linhas, selecionando",
    "Insira Linha Antes / Depois no menu Editar. Você poderia obter o mesmo efeito",
    "colocando muitas sub circuitos complicado em paralelo dentro de uma linha,",
    "mas é mais claro usar múltiplas linhas.",
    "",
    "Depois de ter escrito um programa, você pode testá-lo em simulação e, em seguida",
    "você pode compilá-lo para gerar um arquivo .HEX para o PLC.",
    "",
    "",
    "SIMULAÇÃO",
    "==========",
    "",
    "Para entrar no modo de simulação, escolha Simulação -> Modo Simulação ou pressione",
    "<Ctrl+M>. O programa é apresentado de forma diferente no modo de simulação. Não há",
    "cursor. As instruções que são energizados aparecem em vermelho brilhante;",
    "As instruções que não estão energizadas parecem esverdeadas. Pressione a barra de espaço",
    "para simular um ciclo do PLC. Para ciclo contínuo em tempo real, escolher",
    "Simular -> Iniciar Simulação em Real-Time, ou pressione <Ctrl+R>. As alterações",
    "são mostradas em tempo real conforme o programa muda.",
    "",
    "Você pode definir o estado das entradas para o programa clicando duas vezes",
    "na lista na parte inferior da tela, ou clicando duas vezes uma instrução de contato `Xname'.",
    "Se você alterar o estado de uma porta de entrada, ",
    "as alterações não serão refletidas na forma como o programa",
    "é mostrado até que um ciclo do PLC aconteça; isto ira acontecer automaticamente se",
    "você estiver executando a simulação em tempo real, ou quando você pressionar a barra de espaço.",
    "",
    "",
    "INSTRUÇÕES",
    "==========",
    "",
    "> CONTATO, NORMALMENTE ABERTO        Xname           Rname          Yname",
    "                                  ----] [----     ----] [----    ----] [----",
    "",
    "    Tecla de atalho : C",
    "    Pode ser aplicado à : Pinos de entrada, Pinos de saída, Relés internos",
    "    Se o sinal da instrução (contato) é falso, a saída de sinal também será",
    "    falsa. Interprete como uma chave com conexões em contato normalmente aberto, que",
    "    quando acionado fecha o circuito.",
    "",
    "",
    "> CONTATO, NORMALMENTE FECHADO      Xname           Rname          Yname",
    "                                 ----]/[----     ----]/[----    ----]/[----",
    "",
    "    Tecla de atalho : C",
    "    Pode ser aplicado à : Pinos de entrada, Pinos de saída, Relés internos",
    "    Se o sinal entrar de entrada for falso, a saída é verdadeira. Se o sinal de",
    "    entrada for verdadeiro, a saída é falsa. Entenda como uma chave com conexões em",
    "    contato normalmente fechado, que quando é acionada irá abrir o circuito,",
    "    interrompendo a passagem de sinal.",
    "    Esta instrução é similar a anterior, com a diferença da opção |\\|Negated",
    "    ativada.",
    "",
    "",
    "> BOBINA, NORMAL                  Rname           Yname",
    "                               ----( )----     ----( )----",
    "",
   "    Tecla de atalho: L",
   "    Aplica-se à: Relé interno e pinos de saída",
   "    ",
   "    Se o sinal vindo das instruções é verdadeiro, então a saída em questão irá",
   "    ser ativada. Se o sinal é falso (circuito aberto), a saída será desativada. Esta",
   "    instrução sempre estará mais a direita possível no diagrama ladder. Podem ser",
   "    inseridas em paralelo, mas não em série.",
    "",
    "",
    "> BOBINA, NEGATED                 Rname           Yname",
    "                             ----(/)----     ----(/)----",
    "",
   "    Tecla de atalho: L",
   "    Aplica-se à: Relé interno e pinos de saída",
   "    ",
   "    Se o sinal que vai à instrução é verdadeiro, então a saída em questão é",
   "    desativada. Caso o sinal de entrada seja falso (circuito aberto), a saída será",
   "    ativada. Similar à instrução anterior com o valor invertido.",
   "    ",
    "",
    "",
    "> BOBINA, SET-ONLY                Rname           Yname",
    "                             ----(S)----     ----(S)----",
    "",
    "    Tecla de atalho: L",
    "    Aplica-se à: Relé interno e pinos de saída",
    "    ",
    "    Com esta opção, estabelece-se que a saída em questão irá ter seu estado",
    "    modificado para ATIVADO quando a entrada de sinal for verdadeira, e não",
    "    desativará quando o sinal de entrada for falso.",
    "    ",
    "",
    "",
    "> BOBINA, RESET-ONLY              Rname           Yname",
    "                             ----(R)----     ----(R)----",
    "",
    "         Se o sinal que chega a instrução for verdadeiro, então o relé interno ou",
    "   pino de saída será desativado. Caso contrário, o pino de saída ou relé interno",
    "   não terá seu estado modificado. Esta instrução somente poderá mudar o estado do",
    "   pino de LIGADO para DESLIGADO, e geralmente isso é utilizado em combinação com",
    "   uma ação BOBINA SET-ONLY. Esta instrução deve ser a mais a direita possível.",
    "    ",
    "",
    "",
    "> TURN-ON DELAY (TEMPORIZADOR)       ",
    "                                Tdon ",
    "                           -[TON 1.000 s]-",
    "",
    "    Quando o sinal que vai para a instrução comutar de DESLIGADO para LIGADO",
    "    (borda de subida), a saída permanecerá falsa por N segundos antes de ser ativado.",
    "    Quando o sinal de entrada mudar de LIGADO para DESLIGADO, a saída irá para",
    "    DESLIGADO imediatamente. O temporizador é reiniciado sempre que a entrada estiver",
    "    em nível DESLIGADO. O tempo (N) é configurável. No exemplo, o valor é de 1",
    "    segundo)",
    "",
     "    O nome ‘Tdon’ irá contar a partir de zero em unidades de scantimes. A",
    "    instrução de saída TON irá proporcionar saída em nível alto sempre que o contador",
    "    de ciclos for igual ou superior ao delay escolhido. É também possível manitular",
    "    esta variável contadora ‘Tdon’, por exemplo com instruções de manipulação de",
    "    dados como a instrução MOV.",
    "",
    "",
    "> TURN-OFF DELAY (RETARDO NO DESLIGAMENTO)",
    "    ",
    "                                 Tdoff ",
    "                           -[TOF 1.000 s]-",
    "",
    "    Quando o sinal vindo da instrução muda de LIGADO para DESLIGADO, o sinal de",
    "    saída ainda permanecerá ativado por N segundos antes de desativar. Quando o sinal",
    "    vindo da instrução mudar de DESLIGADO para LIGADO, a saída irá mudar para LIGADO",
    "    imediatamente. O temporizador é reiniciado sempre que a entrada mudar para nível",
    "    DESLIGADO. A entrada precisará estar desativada pelo tempo determinado para que a",
    "    saída mude para estado FALSO. O tempo (N) é configurável.",
    "    ",
    "    A variável ‘Tdoff’ é uma variável contadora crescente que inicia em zero, e",
    "    incrementa em unidades de tempo de ciclo. É possível manipular esta variável de",
    "    tempo através de instruções de manipulação de dados, como a instrução MOV.",
    "    ",
    "",
    "",
    "> RETENTIVE TIMER               Trto  ",
    "                           -[RTO 1.000 s]-",
    "",
    "         Esta instrução está associada ao tempo de duração do pulso da entrada. Se a",
    "    entrada permanecer ligada por mais de N segundos, a saída será ativada. Em outro",
    "    caso, a saída permanecerá falsa. A entrada precisa permanecer acionada por, no",
    "    mínimo, N segundos para ativar a saída, que uma vez ativada, assim o permanecerá",
    "    até que a variável ‘Trto’ em questão seja reiniciada, ou através de uma instrução",
    "    manual de reset.",
    "    ",
    "         É possível manipular o estado da variável contadora de tempo através de",
    "    instruções de manipulação de memória, como a instrução MOV ou RESET.",
    "    ",
    "",
    "> RESET                        Trto             Citems",
    "                           ----{RES}----     ----{RES}----",
    "",
    "        Esta instrução reinicia um timer ou contador. Retardos do tipo TON e TOF são",
    "    automaticamente reiniciados quando as suas entradas mudarem de estado, mas o",
    "    temporizador retentivo não. O temporizador RTO, contadores CTU e CTD não são",
    "    reiniciados automaticamente, e devem ser reiniciados manualmente usando a",
    "    instrução RES. Quando a entrada é verdadeira, o contador ou timer associado é",
    "    reiniciado. Esta instrução necessita ser a instrução mais a direita no degrau",
    "    ladder produzido.",
    "",
    "",
    "> ONE-SHOT RISING (BORDA DE SUBIDA) _",
    "    ",
    "                           --[OSR_/ ]--",
    "",
    "          Esta instrução produz, por padrão, saída DESLIGADA. Se o sinal de entrada",
    "    mudar durante o processo de DESLIGADO para LIGADO a saída será ativada. Isso gera",
    "    um pulso de um ciclo na saída, e pode ser usado para disparar eventos baseados na",
    "    borda de subida de um sinal.",
    "",
    "",
    "> ONE-SHOT FALLING (BORDA DE DESCIDA) _",
    "",
    "                           --[OSF \\_]--",
    "",
    "    Esta instrução produz, por padrão, saída DESLIGADA. Se o sinal de entrada",
    "    mudar durante o processo de LIGADO para DESLIGADO a saída será ativada. Isso gera",
    "    um pulso de um ciclo na saída, e pode ser usado para disparar eventos baseados na",
    "    borda de descida de um sinal.",
    "    ",
    "",
    "",
    "> SHORT CIRCUIT, OPEN CIRCUIT (CIRCUITO FECHADO, CIRCUITO ABERTO) ",
    "    ",
    "                           ----+----+----      ----+     +----",
    "",
    "    A condição de saída de um CIRCUITO FECHADO é sempre igual a sua condição de",
    "    entrada, e o estado do sinal da saída de um CIRCUITO ABERTO é sempre desligado.",
    "    Isso pode ser útil para depurar o programa em situações de análise e teste.",
    "",
    "",
    "> MASTER CONTROL RELAY (RELÉ PRINCIPAL) ",
    "                           -{MASTER RLY}-",
    "",
    "    Por padrão, todos os degraus tem condição de entrada LIGADA. Este relé",
    "    principal realiza controle esta entrada, e pode desativar estas entradas. Dentro",
    "    do ciclo do programa, podem ser adicionadas instruções para ativação e",
    "    desativação parciais do MASTER RLY, sendo isso bastante útil para depuração.",
    "    ",
    "   ",
    "",
    "",
    "> MOVE                      {destvar :=  }      {Tret :=     }",
    "                           -{ 123     MOV}-    -{ srcvar  MOV}-",
    "",
    "    Quando o sinal de entrada desta instrução for LIGADO, a variável de destino",
    "    será carregada com o valor da variável de origem ou da constante. Se o sinal de",
    "    entrada estiver DESLIGADO, nada acontece com a variável. Você pode utilizar a",
    "    instrução MOVE com qualquer variável, incluindo contadores e temporizadores.",
    "    Esta instrução precisa ser a mais a direita no degrau de instruções.",
    "",
    "",
    "> OPERAÇÃO ARITMÉTICA        {ADD  kay  :=}       {SUB  Ccnt :=}",
    "                            -{ 'a' + 10   }-     -{ Ccnt - 10  }-",
    "",
    ">                            {MUL  dest :=}       {DIV  dv :=  }",
    "                            -{ var * -990 }-     -{ dv / -10000}-",
    "",
    "    Quando o sinal de entrada desta instrução é verdadeiro, a variável de",
    "    destino é carregada com o resultado da expressão. Isso pode ser realizado também",
    "    em variáveis de contagem e temporizadores. Estas instruções aritméticas utilizam",
    "    um processamento aritmético de números 16 bits com sinal. Cada ciclo de",
    "    processamento desencadeia uma operação aritmética, caso o sinal de entrada esteja",
    "    verdadeiro. Se você usar esta instrução para incrementar ou decrementar uma",
    "    variável, e isso estiver associado a um sinal de entrada (tipo um botão), use a",
    "    instrução de borda de subida ou descida para que o incremento ou decremento",
    "    ocorra somente em uma operação por pulso de entrada. A divisão é truncada, e não",
    "    arredondada. 8 / 3 resulta em 2.",
    "    Esta instrução precisa ser a mais a direita no bloco (degrau) em uso.",
    "",
    "",
    "> COMPARE(COMPARAÇÃO)   [var ==]        [var >]        [1 >=]",
    "                       -[ var2 ]-      -[ 1   ]-      -[ Ton]-",
    "",
    ">                       [var /=]       [-4 <   ]       [1 <=]",
    "                       -[ var2 ]-     -[ vartwo]-     -[ Cup]-",
    "",
    "    Se o sinal de entrada para esta instrução é DESLIGADO, então a saída também",
    "    é DESLIGADA. Se o sinal de entrada for LIGADO, então a saída será LIGADA se e",
    "    somente se a instrução de comparação for verdadeira. Esta instrução pode ser",
    "    usada para comparação (igual, maior que, maior e igual, diferente, menor que,",
    "    menor e igual) entre variáveis, ou para comparar uma variável com uma constante",
    "    numérica de 16 bits.",
    "",
    "",
    "> COUNTER  (CONTADOR)          Cname          Cname",
    "                           --[CTU >=5]--  --[CTD >=5]--",
    "",
    "    Um contador incremental (CTU, conut up) ou decrementa (CTD, count down) é",
    "    associado à deteção de borda de uma determinada condição de entrada. O sinal de",
    "    saída desta instrução é verdadeiro caso o valor do contador tenha atingido o",
    "    valor limite.",
    "    Você pode utilizar instrução de incremento (CTU) e decremento (CTD) com",
    "    variáveis de mesmo nome, e a instrução RES para reiniciar o valor do mesmo.",
    "",
    "",
    "> CIRCULAR COUNTER (CIRCULAR COUNTER)",
    ">                              Cname",
    "                           --{CTC 0:7}--",
    "",
    "    Um contador circular trabalha como um contador normal, exceto pelo fato de,",
    "    após atingir o limite, ele reinicia voltando ao valor inicial. Por exemplo, o",
    "    contador acima, se incrementado, contará 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4,",
    "    5, 6, 7, 0, 1, 2, ...",
    "    Isso pode ser muito útil se combinado com estruturas condicionais na",
    "    variável ‘Cname’, podendo ser criado o efeito de seqüenciador. CTC conta na borda",
    "    de subida do sinal de entrada, e esta instrução deve ser a mais a direita no",
    "    bloco (degrau) ladder.",
    "",
    "",
    "> SHIFT REGISTER            {SHIFT REG   }",
    "                           -{ reg0..3    }-",
    "",
    "    Um SHIFT REGISTER (Registrador de deslocamento) é associado a um grupo de",
    "    variáveis. Por exemplo, este registrador pode ser associado com as variáveis",
    "    ‘reg0’, ‘reg1’, ‘reg2’ e ‘reg3’.",
    "    A cada pulso (borda de subida) na entrada desta instrução, ocorre o",
    "    deslocamento (reg3 ? reg2, reg2 ? reg1, reg1 ? reg0, e reg0 permanece",
    "    inalterado).",
    "    Observe que esta instrução consome uma área significativa de memória, e",
    "    deve ser usada com cuidado.",
    "    Ela precisa ser a instrução mais à direita no degrau em uso.",
    "",
    "",
    "",
    "> LOOK-UP TABLE             {dest :=     }",
    "                           -{ LUT[i]     }-",
    "",
    "    Uma tabela look-up é um conjunto de n dados ordenados. Quando a condição de",
    "    entrada for LIGADO, a variável de destino ‘dest’ será carregada com o valor da",
    "    variável de origem na ocorrência ‘i’. O índice (i) inicia em zero. Esta instrução",
    "    deve ser a mais a direita no degrau em uso.",
    "    ",
    "",
    "",
    "> PIECEWISE LINEAR TABLE    {yvar :=     }",
    "                           -{ PWL[xvar]  }-",
    "",
    "    Esta é a melhor forma de aproximar uma complicada função de transformação",
    "    não linear. Pode ser útil, por exemplo, se você tiver que associar os valores",
    "    lidos a uma curva de calibração baseado no valor de entrada de um sensor.",
    "    Você pode entrar com dados na tabela associando com um valor linear",
    "    desejado. O valor será atribuído a variável xvar, e isso define o valor da",
    "    valores.",
    "",
    "    Os pontos precisam ser especificados em ordem crescente em xvar. Em alguns",
    "    casos, por questões matemáticas e de limitações do processamento aritmético de 16",
    "    bits, o POPTools poderá gerar mensagens de erro relativas a conversão. Neste caso,",
    "    adicione mais dados à tabela.",
    "    Ex: Isso irá produzir um erro, se lançado estes dois pontos:",
    "",
    "        f(0)   = 2",
    "        f(5)   = 10",
    "        f(10)  = 50",
    "        f(100) = 100",
    "",
    "    TQue pode ser corrigido desta forma:",
    "",
    "        (x0, y0)   = (  0,   2)",
    "        (x1, y1)   = (  5,  10)",
    "        (x2, y2)   = ( 10,  50)",
    "        (x3, y3)   = (100, 100)",
    "",
    "    Em casos extremos pode ser necessário usar mais de cinco ou seis pontos.",
    "    Adicionando mais pontos o código fica maior e mais lento para ser executado",
    "    A instrução precisa ser a mais à direita do degrau em uso.",
    "",
    "",
    "> A/D CONVERTER READ           Aname",
    "                           --{READ ADC}--",
    "",
    "    POPTools pode gerar código para usar o conversor A/D do CLP",
    "    Se a condição de entrada para esta instrução é LIGADO, então",
    "    será obtida uma simples amostra do conversor A/D e isso é armazenado na variável",
    "    chamada ‘Aname’. Testa variável pode ser manipulada com operações genéricas, como",
    "    comparação e atribuição.",
    "    Associe o pino à variável ‘Axxx’ da mesma forma que é associado um pino de",
    "    entrada/saída digital, clicando duplamente na parte inferior da tela.",
    "    Entradas de 0 Volts corresponde ao valor 0, e uma entrada na tensão máxima",
    "    do sistema (Vdd) corresponde ao valor 1023 (AD de 10 bits).",
    "    O software não irá permitir que você associe pinos que não sejam entradas anlógicas",
    "",
    "",
    "> SET PWM DUTY CYCLE          duty_cycle",
    "                           -{PWM 32.8 kHz}-",
    "",
    "    POPTools can generate code to use the PWM peripheral built in to",
    "    certain microcontrollers. If the input condition to this instruction",
    "    is true, then the duty cycle of the PWM peripheral is set to the",
    "    value of the variable duty_cycle. The duty cycle must be a number",
    "    between 0 and 100; 0 corresponds to always low, and 100 corresponds to",
    "    always high. (If you are familiar with how the PWM peripheral works,",
    "    then notice that that means that POPTools automatically scales the",
    "    duty cycle variable from percent to PWM clock periods.)",
    "",
    "    You can specify the target PWM frequency, in Hz. The frequency that",
    "    you specify might not be exactly achievable, depending on how it",
    "    divides into the microcontroller's clock frequency. POPTools will",
    "    choose the closest achievable frequency; if the error is large then",
    "    it will warn you. Faster speeds may sacrifice resolution.",
    "",
    "    This instruction must be the rightmost instruction in its rung.",
    "    The ladder logic runtime consumes one timer to measure the cycle",
    "    time. That means that PWM is only available on microcontrollers",
    "    with at least two suitable timers. PWM uses pin CCP2 (not CCP1)",
    "    on PIC16 chips and OC2 (not OC1A) on AVRs.",
    "",
    "",
    "> MAKE PERSISTENT            saved_var",
    "                           --{PERSIST}--",
    "",
    "    Quando a instrução de entrada é LIGADA, isso fará com que determinada",
    "    variável seja salva na EEPROM. Isso significa que o valor persistirá quando o",
    "    sistema for desativado (desconectado da energia elétrica).",
    "    Não é necessário declarar o local onde a informação será gravada, isso",
    "    ocorrerá de forma automática, e a variável será automaticamente carregada quanto",
    "    o sistema for reiniciado.",
    "    Se o sistema abusar deste recurso, gravando muito freqüentemente na eeprom,",
    "    então este recurso pode ser danificado, pois muitos sistemas garantem um limite",
    "    de 100000 gravações somente.",
    "",
    "",
    "> RS485 (SERIAL) RECEIVE          var",
    "                           --{UART RECV}--",
    "",
    "    POPTools can generate code to use the UART built in to certain",
    "    microcontrollers. On AVRs with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; POPTools will warn you if this is the case.",
    "",
    "    If the input condition to this instruction is false, then nothing",
    "    happens. If the input condition is true then this instruction tries",
    "    to receive a single character from the UART. If no character is read",
    "    then the output condition is false. If a character is read then its",
    "    ASCII value is stored in `var', and the output condition is true",
    "    for a single PLC cycle.",
    "",
    "",
    "> RS485 (SERIAL) SEND             var",
    "                           --{UART SEND}--",
    "",
    "    POPTools can generate code to use the UARTs built in to certain",
    "    microcontrollers. On AVRS with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; POPTools will warn you if this is the case.",
    "",
    "    If the input condition to this instruction is false, then nothing",
    "    happens. If the input condition is true then this instruction writes",
    "    a single character to the UART. The ASCII value of the character to",
    "    send must previously have been stored in `var'. The output condition",
    "    of the rung is true if the UART is busy (currently transmitting a",
    "    character), and false otherwise.",
    "",
    "    Remember that characters take some time to transmit. Check the output",
    "    condition of this instruction to ensure that the first character has",
    "    been transmitted before trying to send a second character, or use",
    "    a timer to insert a delay between characters. You must only bring",
    "    the input condition true (try to send a character) when the output",
    "    condition is false (UART is not busy).",
    "",
    "    Investigate the formatted string instruction (next) before using this",
    "    instruction. The formatted string instruction is much easier to use,",
    "    and it is almost certainly capable of doing what you want.",
    "",
    "",
    "> FORMATTED STRING OVER UART                var",
    "                                   -{\"Pressure: \\3\\r\\n\"}-",
    "",
    "    POPTools can generate code to use the UARTs built in to certain",
    "    microcontrollers. On AVRS with multiple UARTs only UART1 (not",
    "    UART0) is supported. Configure the baud rate using Settings -> MCU",
    "    Parameters. Certain baud rates may not be achievable with certain",
    "    crystal frequencies; POPTools will warn you if this is the case.",
    "",
    "    When the rung-in condition for this instruction goes from false to",
    "    true, it starts to send an entire string over the serial port. If",
    "    the string contains the special sequence `\\3', then that sequence",
    "    will be replaced with the value of `var', which is automatically",
    "    converted into a string. The variable will be formatted to take",
    "    exactly 3 characters; for example, if `var' is equal to 35, then",
    "    the exact string printed will be `Pressure:  35\\r\\n' (note the extra",
    "    space). If instead `var' were equal to 1432, then the behaviour would",
    "    be undefined, because 1432 has more than three digits. In that case",
    "    it would be necessary to use `\\4' instead.",
    "",
    "    If the variable might be negative, then use `\\-3d' (or `\\-4d'",
    "    etc.) instead. That will cause POPTools to print a leading space for",
    "    positive numbers, and a leading minus sign for negative numbers.",
    "",
    "    If multiple formatted string instructions are energized at once",
    "    (or if one is energized before another completes), or if these",
    "    instructions are intermixed with the UART TX instructions, then the",
    "    behaviour is undefined.",
    "",
    "    It is also possible to use this instruction to output a fixed string,",
    "    without interpolating an integer variable's value into the text that",
    "    is sent over serial. In that case simply do not include the special",
    "    escape sequence.",
    "",
    "    Use `\\\\' for a literal backslash. In addition to the escape sequence",
    "    for interpolating an integer variable, the following control",
    "    characters are available:",
    "        * \\r   -- carriage return",
    "        * \\n   -- newline",
    "        * \\f   -- formfeed",
    "        * \\b   -- backspace",
    "        * \\xAB -- character with ASCII value 0xAB (hex)",
    "",
    "    The rung-out condition of this instruction is true while it is",
    "    transmitting data, else false. This instruction consumes a very",
    "    large amount of program memory, so it should be used sparingly. The",
    "    present implementation is not efficient, but a better one will",
    "    require modifications to all the back-ends.",
    "",
    "",
    "Observações ao usar recursos matemáticos",
    "========================================",
    "",
    "Lembre que o POPTools realiza somente instruções matemáticas com inteiros de",
    "32 bits. Isso significa que o resultado final de qualquer cálculo que for",
    "realizado deverá ser um valor inteiro entre -2147483648 and 2147483647.",
    "Isso também quer dizer que valores intermediários de cálculos tambem",
    "devem permanecer nesta faixa.", 
    "Por exmeplo, supondo que você queira calcular y = (1/x)*1200, onde x é um",
    "valor entre 1 e 20. Então y poderá valer 1200 a 60, armazenados em uma variável",
    "inteira de 32 bits. Para isso ser calculado, teoricamente há duas maneiras de se",
    "escrever o código:",
    "you can perform the reciprocal, and then multiply:",
    "",
    "   ||         {DIV  temp  :=}          ||",
    "   ||---------{ 1 / x       }----------||",
    "   ||                                  ||",
    "   ||          {MUL  y  :=  }          ||",
    "   ||----------{ temp * 1200}----------||",
    "   ||                                  ||",
    "",
    "Ou pode realizar a divisão em um passo único :",
    "",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ 1200 / x }-----------||",
    "",
    "",
    "Matematicamente, as duas são equivalents. Mas se você testá-las, poderá",
    "observar que a primeira sempre dará o incorreto resultado de y = 0. Isso é porque",
    "a variável ‘temp’ somente armazenará valores inteiros, e o resultado do primeiro",
    "degrau (1 / x) geralmente será um número menor que 1 (para x = 3, tempo será",
    "0,3333...) e isso não é possível de se armazenar em uma variável inteira.",
    "",
    "Se você estiver tendo problemas nos resultados de suas equações, verifique",
    "portanto os valores intermediários, observando se nenhum valor gerado irá",
    "resultar em dados não armazenáveis em variáveis de 32 bits com sinal.",
    "",
    "Quando você precisar multiplicar uma variável por uma fração, use isso",
    "usando respectivamente as instruções de multiplicação e divisão. Por exemplo,",
    "para multiplicar y por 1.8 * x, calcule: y = (9/5)*x (lembrando que 9/5 = 1.8).",
    "E, no código ladder, faça a multiplicação ocorrer antes da divisão.",
    "",
    "   ||         {MUL  temp  :=}          ||",
    "   ||---------{ x * 9       }----------||",
    "   ||                                  ||",
    "   ||           {DIV  y  :=}           ||",
    "   ||-----------{ temp / 5 }-----------||",
    "",
    "Isso funcionará para qualquer x < (32767 / 9), ou x < 3640. Para valores",
    "maiores de x, a variável ‘temp’ irá sair de seu limite.",
    "",
    "",
    "Estilos de Codificação",
    "======================",
    "",
    "É permitido múltiplas bobinas em paralelo em um simples degrau. Isso",
    "significa que você pode fazer coisas como isso:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    "   ||-------] [------+-------( )-------||",
    "   ||                |                 ||",
    "   ||                |       Yc        ||",
    "   ||                +-------( )-------||",
    "   ||                                  ||",
    "",
    "No lugar disso:",
    "",
    "   ||       Xa               Ya        ||",
    " 1 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yb        ||",
    " 2 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||       Xb               Yc        ||",
    " 3 ||-------] [--------------( )-------||",
    "   ||                                  ||",
    "",
    "Isso permite que, em teoria, você possa escrever programas em um único",
    "degrau gigante. Na prática isso pode não ser uma boa idéia, porque os degraus",
    "ficarão mais complexos e mais difíceis de serem editados, lidos e interpretados.",
    "",
    "Still, it is often a good idea to group related logic together as a single",
    "rung. This generates nearly identical code to if you made separate rungs,",
    "but it shows that they are related when you look at them on the ladder",
    "diagram.",
    "",
    "                  *                 *                  *",
    "",
    "In general, it is considered poor form to write code in such a way that",
    "its output depends on the order of the rungs. For example, this code",
    "isn't very good if both Xa and Xb might ever be true:",
    "",
    "   ||       Xa         {v  :=       }  ||",
    " 1 ||-------] [--------{ 12      MOV}--||",
    "   ||                                  ||",
    "   ||       Xb         {v  :=       }  ||",
    "   ||-------] [--------{ 23      MOV}--||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||                                  ||",
    "   ||      [v >]             Yc        ||",
    " 2 ||------[ 15]-------------( )-------||",
    "   ||                                  ||",
    "",
    "I will break this rule if in doing so I can make a piece of code",
    "significantly more compact, though. For example, here is how I would",
    "convert a 4-bit binary quantity on Xb3:0 into an integer:",
    "",
    "   ||                                   {v  :=       }  ||",
    " 3 ||-----------------------------------{ 0       MOV}--||",
    "   ||                                                   ||",
    "   ||       Xb0                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 1    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb1                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 2    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb2                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 4    }-----------||",
    "   ||                                                   ||",
    "   ||       Xb3                  {ADD  v  :=}           ||",
    "   ||-------] [------------------{ v + 8    }-----------||",
    "   ||                                                   ||",
    "",
    "If the MOV statement were moved to the bottom of the rung instead of the",
    "top, then the value of v when it is read elsewhere in the program would",
    "be 0. The output of this code therefore depends on the order in which",
    "the instructions are evaluated. Considering how cumbersome it would be",
    "to code this any other way, I accept that.",
    "",
    */"",
    "",
    NULL
};
#endif
  /*  SizeRichEdit(a);

    int i;
    BOOL nextSubHead = FALSE;
    for(i = 0; Text[a][i]; i++) {
        char *s = Text[a][i];

        CHARFORMAT cf;
        cf.cbSize = sizeof(cf);
        cf.dwMask = CFM_BOLD | CFM_COLOR;
        cf.dwEffects = 0;
        if((s[0] == '=') ||
           (Text[a][i+1] && Text[a][i+1][0] == '='))
        {
            cf.crTextColor = RGB(255, 255, 110);
        } else if(s[3] == '|' && s[4] == '|') {
            cf.crTextColor = RGB(255, 110, 255);
        } else if(s[0] == '>' || nextSubHead) {
            // Need to make a copy because the strings we are passed aren't
            // mutable.
            char copy[1024];
            if(strlen(s) >= sizeof(copy)) oops();
            strcpy(copy, s);

            int j;
            for(j = 1; copy[j]; j++) {
                if(copy[j] == ' ' && copy[j-1] == ' ')
                    break;
            }
            BOOL justHeading = (copy[j] == '\0');
            copy[j] = '\0';
            cf.crTextColor = RGB(110, 255, 110);
            SendMessage(RichEdit[a], EM_SETCHARFORMAT, SCF_SELECTION,
                (LPARAM)&cf);
            SendMessage(RichEdit[a], EM_REPLACESEL, (WPARAM)FALSE,
                (LPARAM)copy);
            SendMessage(RichEdit[a], EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            
            // Special case if there's nothing except title on the line
            if(!justHeading) {
                copy[j] = ' ';
            }
            s += j;
            cf.crTextColor = RGB(255, 110, 255);
            nextSubHead = !nextSubHead;
        } else {
            cf.crTextColor = RGB(255, 255, 255);
        }

        SendMessage(RichEdit[a], EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
        SendMessage(RichEdit[a], EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)s);
        SendMessage(RichEdit[a], EM_SETSEL, (WPARAM)-1, (LPARAM)-1);

        if(Text[a][i+1]) {
            SendMessage(RichEdit[a], EM_REPLACESEL, FALSE, (LPARAM)"\r\n");
            SendMessage(RichEdit[a], EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
        }
    }

    SendMessage(RichEdit[a], EM_SETSEL, (WPARAM)0, (LPARAM)0);
}
*/
//-----------------------------------------------------------------------------
// Window proc for the help dialog.
//-----------------------------------------------------------------------------
/*static LRESULT CALLBACK HelpProc(HWND hwnd, UINT msg, WPARAM wParam,
    LPARAM lParam)
{
    int a = (hwnd == HelpDialog[0] ? 0 : 1);
    switch (msg) {
        case WM_SIZING: {
            RECT *r = (RECT *)lParam;
 //           return Resizing(r, wParam);
            break;
        }
        case WM_SIZE:
//            SizeRichEdit(a);
            break;

        case WM_ACTIVATE:
        case WM_KEYDOWN:
            SetFocus(RichEdit[a]);
            break;
    
        case WM_DESTROY:
        case WM_CLOSE:
            HelpWindowOpen[a] = FALSE;
            // fall through
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 1;
}
*/
//-----------------------------------------------------------------------------
// Create the class for the help window.
//-----------------------------------------------------------------------------
/*static void MakeClass(void)
{
    WNDCLASSEX wc;
    memset(&wc, 0, sizeof(wc));
    wc.cbSize = sizeof(wc);

    wc.style            = CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW | CS_OWNDC |
                          CS_DBLCLKS;
    wc.lpfnWndProc      = (WNDPROC)HelpProc;
    wc.hInstance        = Instance;
    wc.hbrBackground    = (HBRUSH)GetStockObject(BLACK_BRUSH);
    wc.lpszClassName    = "POPToolsHelp";
    wc.lpszMenuName     = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = (HICON)LoadImage(Instance, MAKEINTRESOURCE(4000),
                            IMAGE_ICON, 32, 32, 0);
    wc.hIconSm          = (HICON)LoadImage(Instance, MAKEINTRESOURCE(4000),
                            IMAGE_ICON, 16, 16, 0);

    RegisterClassEx(&wc);
}

void ShowHelpDialog(BOOL about)
{
    int a = about ? 1 : 0;
    if(HelpWindowOpen[a]) {
        SetForegroundWindow(HelpDialog[a]);
        return;
    }

    MakeClass();

    char *s = about ? _("About LDmicro") : _("POPTools Help");
    HelpDialog[a] = CreateWindowEx(0, "POPToolsHelp", s,
        WS_OVERLAPPED | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX |
        WS_SIZEBOX,
        100, 100, 650, 300+10*FONT_HEIGHT, NULL, NULL, Instance, NULL);
    MakeControls(a);
   
    ShowWindow(HelpDialog[a], TRUE);
    SetFocus(RichEdit[a]);

    HelpWindowOpen[a] = TRUE;

    RECT r;
    GetClientRect(HelpDialog[a], &r);
    TitleHeight = 300 - r.bottom;

    GetWindowRect(HelpDialog[a], &r);
    Resizing(&r, WMSZ_TOP);
    SetWindowPos(HelpDialog[a], HWND_TOP, r.left, r.top, r.right - r.left, 
        r.bottom - r.top, 0);
}*/